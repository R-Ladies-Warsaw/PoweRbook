[
["intro.html", "PoweR, czyli Python i R w Data Science dla początkujących 1 Wstęp", " PoweR, czyli Python i R w Data Science dla początkujących Anna Kozak 2020-04-09 1 Wstęp Przedstawiamy mini podręcznik do nauki Pythona i R w Data Science. Zebrane materiały są częścią warsztatów “PoweR, czyli Python i R w Data Science dla początkujących” organizowanych przez: Warszawskie Spotkania Entuzjastów R R Ladies Warsaw Koło Naukowe Data Science PW MI2DataLab Wydział Matematyki i Nauk Informacyjnych, Politechnika Warszawska Nasi prowadzący: Część 1 - Podstawy języka Grupa Python - Kasia Stankiewicz Kasia jest studentką 3 roku Informatyki na MiNI, zakochana w Data Science. Już od kilku lat bierze udział w prowadzeniu różnego rodzaju wykładów i warsztatów. W wolnym czasie jest wiceprezesem Koła Naukowego Data Science na PW i wspina się na skałkach. Grupa R - Alicja Gosiewska Alicja jest doktorantką informatyki na Politechnice Warszawskiej związaną z MI2 Data Labem. Uwielbia wprowadzać ludzi w świat programowania w R podczas warsztatów, często wspieranych przez R-Ladies Warsaw. W pracy naukowej zajmuje się wyjaśnialnym uczeniem maszynowym, jest autorką pakietów R takich jak auditor czy iBreakDown. Część 2 - Formatowanie danych Grupa Python - Kuba Wiśniewski Kuba jest studentem Inżynierii i Analizy Danych na Politechnice Warszawskiej. W wolnych chwilach udziela się w Kole Naukowym Data Science. Lubi kontakt z ludźmi, sport i gotowanie. Grupa R - Kasia Woźnica Kasia jest doktorantką Politechniki Warszawskiej na informatyce. Pracuje też w MI2 Data Lab. W pracy naukowej zajmuje się automatycznym uczeniem maszynowym. Po godzinach lubi dzielić się z innymi swoimi umiejętnościami z programowania w R, a prowadzenie warsztatów jest ku temu świetną okazją. Część 3 - Wizualne EDA Grupa Python - Wojtek Tyczyński Wojtek jest studentem Fizyki Technicznej na Politechnice Warszawskiej i wiceprezesem Koła Naukowego Data Science. Do jego głównych zainteresowań, poza data science, należy również wykorzystanie machine learningu w fizyce. Ponadto jest zawodnikiem jednej z warszawskich drużyn Futbolu Amerykańskiego. Grupa R - Ania Kozak Ania jest studentką Statystyki Matematycznej i Analizy Danych na Politechnice Warszawskiej oraz pracuje jako Data Scientist. Związana z MI2 Data Lab oraz Kołem Naukowym Data Science. W wolnych chwilach organizuje i prowadzi warsztaty (SER Warsaw, R Ladies Warsaw) związane z popularyzacją języka R. Jest autorką pakietu R vivo. Gdy nie programuje jest cukieRnikiem ;) "],
["podstawy-jezyka.html", " 2 Podstawy języka 2.1 R 2.2 Python", " 2 Podstawy języka Wstęp do Pythona i R 2.1 R 2.1.1 Podstawowe operacje Poniższy kod został napisany i wygenerowany RStudio. Jest to najbardziej powszechne środowisko programistyczne R-a, integrujące także wiele innych przydatnych funkcjonalności. Aplikacja jest darmowa i łatwa do zainstalowania na większości systemów operacyjnych. R to bardzo wygodne narzędzie w kwestii operacji arytmetycznych. Sprawdźmy jak sprawdzi się dla paru z nich! 2 + 2 ## [1] 4 2 + 2 + 2 + 2 ## [1] 8 2^4 ## [1] 16 Oprócz wyżej wymienionych można także dokonywać wielu innych obliczeń. Zadanie 1 Sprawdź czy R zachowuje kolejność dzialań. Jakiego przykladu można uzyć? Przykładowe rozwiązanie: 2 + 2 * 2 ## [1] 6 W R-rze istnieją dwie metody przypisania. Głownie używamy składni x &lt;- 5 (możliwe także 5 -&gt; x), ale istnieje rownież opcja może bardziej instynktownego x = 5. Standardowo przynajmniej na tym etapie lepiej jest jednak używać “strzałki”. x &lt;- 5 x ## [1] 5 y = 5 zmienna &lt;- &quot;Hello World!&quot; 2.1.2 Struktury danych Jedną z podstawowych są wektory. Służą one do przechowywania pewnej liczby elementów w jednej zmiennej. parzyste &lt;- c(2, 4, 6) litery &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) litery[2] ## [1] &quot;b&quot; vec &lt;- c(parzyste, litery) vec ## [1] &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; Oczywiście i na nich możemy dokonywać różnych operacji. nieparzyste &lt;- c(1, 3, 5) parzyste + nieparzyste ## [1] 3 7 11 parzyste * x ## [1] 10 20 30 Inną istotną strukturą są listy. liczby &lt;- list(parzyste = parzyste, nieparzyste = nieparzyste) c(parzyste, nieparzyste) ## [1] 2 4 6 1 3 5 liczby[[1]] ## [1] 2 4 6 liczby[[&quot;parzyste&quot;]] ## [1] 2 4 6 Zadanie 2 Stwórz dwa wektory składające się z 5 liczb każdy, a następnie przypisz ich rożnice do nowej zmiennej o nazwie różnica. Połącz te trzy wektory w listę. Przykładowe rozwiązanie: a &lt;- c(1, 2, 3, 4, 5) b &lt;- c(6, 7, 8, 9, 10) roznica &lt;- b - a lista_wektorow &lt;- list(a, b, roznica) R jest także bogaty w szereg przydatnych funkcji wbudowanych. Oto niektóre z nich i ich działanie: ?min # zwraca informacje o funkcji min(roznica) ## [1] 5 max(roznica) ## [1] 5 sum(roznica) ## [1] 25 length(roznica) ## [1] 5 vec2 &lt;- 1:20 vec2 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 vec3 &lt;- 50:100 vec3 ## [1] 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 ## [18] 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 ## [35] 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 Kolejną bardzo ważną strukturą w R jest ramka danych. df &lt;- data.frame(col_1 = c(1, 2, 3), col_2 = c(&quot;raz&quot;, &quot;dwa&quot;, &quot;trzy&quot;)) Możemy na niej działać poprzez odpowiednie operatory: df$col_1 ## [1] 1 2 3 df[[&quot;col_1&quot;]] ## [1] 1 2 3 df[3, 1] ## [1] 3 df[,1] ## [1] 1 2 3 df[1,] ## col_1 col_2 ## 1 1 raz df[2:3,] ## col_1 col_2 ## 2 2 dwa ## 3 3 trzy 2.1.3 Instrukcja warunkowa … to konstrukcja, której używamy w celu dokonywania decyzji o wykonywanych krokach. Najprościej mówiąc owy element języka pozwala na wykonanie ciągu operacji w zależności od zaproponowanego przez programistę warunku. Oto i przykładowe takie warunki: 1 == 1 ## [1] TRUE 1 == 0 ## [1] FALSE 1 &gt; 0 ## [1] TRUE 1 &lt; 0 ## [1] FALSE !(1==1) ## [1] FALSE parzyste ## [1] 2 4 6 parzyste == 2 ## [1] TRUE FALSE FALSE all(parzyste == 2) ## [1] FALSE any(parzyste == 2) ## [1] TRUE 2 %in% parzyste ## [1] TRUE … i sama instrukcja if w praktyce: if( !(8 %in% parzyste) ){ parzyste &lt;- c(parzyste, 8) } parzyste ## [1] 2 4 6 8 skorupa &lt;- TRUE if(skorupa == TRUE){ &quot;zolw&quot; } else { &quot;kot&quot; } ## [1] &quot;zolw&quot; ifelse(skorupa == TRUE, &quot;zolw&quot;, &quot;kot&quot;) ## [1] &quot;zolw&quot; ifelse działa też na wektorze: skorupa &lt;- c(TRUE, TRUE, FALSE) ifelse(skorupa == TRUE, &quot;zolw&quot;, &quot;kot&quot;) ## [1] &quot;zolw&quot; &quot;zolw&quot; &quot;kot&quot; Zadanie 3 Podobnie jak w powyższym przykładzie, wektor liczb nieparzystych powiększ o liczbe 7, o ile już jej nie ma. Dany jest wektor liczb, v &lt;- c(1,2,2,2,2,2,3,3,3,1,1,2). Użyj instrukcji if, else lub ifelse, żeby zrobić z niego wektor zawierający wartości “jeden”, “dwa”, “trzy”. Przykładowe rozwiązanie: if( !(7 %in% nieparzyste) ){ nieparzyste &lt;- c(nieparzyste, 7) } nieparzyste ## [1] 1 3 5 7 v &lt;- 2 ifelse(v == 1, &quot;jeden&quot;, ifelse(v == 2, &quot;dwa&quot;, &quot;trzy&quot;)) ## [1] &quot;dwa&quot; 2.1.4 Pętle Często spotykamy się z sytuacją, kiedy daną operację lub ciąg wielu instrukcji chcemy wykonać wielokrotnie. Do tego właśnie używamy tytułowych konstrukcji. Dwie najbardziej powszechne to while i for. Pierwsza z nich działa na podobnej zasadzie jak intrukcja if - z tym wyjątkiem, że warunek sprawdzany jest wielokrotnie - tak długo, aż będzie spełniany. while (length(parzyste) &lt; 10) { len &lt;- length(parzyste) parzyste &lt;- c(parzyste, parzyste[len] + 2) } Z drugiej strony for udostępnia nam możliwość wykonania operacji konkretną ilość razy - np. dokonując czynności dla każdej liczby z listy. nieparzyste2 &lt;- c() for(liczba in parzyste){ nieparzyste2 &lt;- c(nieparzyste2, liczba - 1) } Zadanie 4 Użyj pętli (której?), żeby iterując po wektorze liczby &lt;- 1:10 stworzyć wektor 10 kolejnych liczb nieparzystych. Czy jest więcej niż jeden sposob? Przykładowe rozwiązanie: a) nieparzyste3 &lt;- c() for(x in 1:10){ nieparzyste3 &lt;- c(nieparzyste3, 2 * x - 1) } Ależ oczywiście, że tak! 2.1.5 Pliki i odczyt danych Bardzo istotnymi funkcjami są getwd() i setwd() - pierwsza zwraca ścieżkę do roboczego katalogu roboczego, zaś druga umożliwia ustawienie nowej. getwd() setwd(&quot;/Users/ja/mojeskrypty&quot;) Do odczytania ramki danych możemy użyć funkcji read.csv() - w tym celu jako pierwszy argument podajemy ścieżkę do naszego pliku, a jako opcjonalny drugi - separator [znak lub ciąg oddzielający kolejne kolumki data frame]. # seriale &lt;- read.csv(&quot;&lt;tu nalezy wkleic sciezke do pliku&gt;&quot;, sep=&quot;;&quot;) seriale &lt;- read.csv(&quot;files/netflix_titles.csv&quot;) Zobaczmy efekt wywołania naszej funkcji - operacja head() zwróci nam kilka pierwszych wierszy, zaś View() udostępnia estetyczny ogląd tabelki. head(seriale) View(seriale) Zadanie 5 Wypisz nazwy seriali, które wyszły w 2020 roku. Wybierz podzbiór zawierający Twoje 3 ulubione seriale i przypisz go do nowej zmiennej. Przykładowe rozwiązanie: a) Tworzymy wektor, który odpowiada kolejnym wierszom z ramki danych, jeśli zawiera TRUE, to znaczy, że serial był wydany w 2020, jeśli FALSE oznacza, że serial byl wydany w innym roku. ktore_w_2020 &lt;- seriale[[&quot;release_year&quot;]] == 2020 Możemy użyc wektora TRUE/FALSE do indeksowania wierszy. Poniższe polecenie wybierze tylko te wiersze, w których wektor ktore_w_2020 przyjął wartość TRUE. seriale_2020 &lt;- seriale[ktore_w_2020, ] moje_seriale &lt;- seriale[c(1, 2, 10), ] 2.2 Python 2.2.1 Podstawy i proste typy print(&quot;Hi!&quot;) ## Hi! Python jest językiem interpretowanym - najprościej mówiąc oznacza to, że jest on tłumaczony i wykonywany “w locie”. Tłumaczeniem i wykonywaniem programu zajmuje się specjalny program nazwany interpreterem języka. Najprostszym typem jest int - obejmuje on liczby całkowite. x = 21 print(x) print(type(x)) y = 0.3 print(y) print(type(y)) ## 21 ## &lt;class &#39;int&#39;&gt; ## 0.3 ## &lt;class &#39;float&#39;&gt; def fun(x, y): return x + y x = &quot;Data&quot; y = &quot;Science&quot; print(fun(x, y)) x = 5 y = 7 print(fun(x, y)) ## DataScience ## 12 Python jest dynamicznie typowany i typowanie jest silne - oznacza to, że język nie może niejawnie konwertować wartości różnych typów. a = 2 b = &#39;L&#39; c = a + b # zwróci błąd Wartości niektórych obiektów mogą ulec zmianie. Obiekty, których wartość może ulec zmianie, są nazywane mutable; obiekty, których wartość jest niezmienna po ich utworzeniu, nazywane są immutable. Typ logiczny bool to dwie stałe: True i False. a = True print(a) print(type(a)) b = False print(b) print(type(a)) ## True ## &lt;class &#39;bool&#39;&gt; ## False ## &lt;class &#39;bool&#39;&gt; bool jest podtypem liczby całkowitej (int). Funkcja isinstance() została zaprojektowana specjalnie w celu sprawdzenia, czy dane należą do określonej klasy (typu danych), zaś funkcja issubclass() wskazuje, czy określona klasa jest podklasą określonych klas. print(isinstance(True, int)) print(isinstance(False, int)) print(issubclass(bool, int)) ## True ## True ## True x = True y = 1 z = False print(x + y) print(y + z) ## 2 ## 1 W Pythonie wartość liczby całkowitej nie jest ograniczona liczbą bitów i może wzrosnąć do limitu dostępnej pamięci. W porównaniu do np. C++ gdzie int ma wartości od -2147483648 do 2147483647 - 4 bajty. x = 78 y = -5 z = 100 ** 20 print(type(x), x) print(type(y), y) print(type(z), z) ## &lt;class &#39;int&#39;&gt; 78 ## &lt;class &#39;int&#39;&gt; -5 ## &lt;class &#39;int&#39;&gt; 10000000000000000000000000000000000000000 Liczby możemy zapisywać także w w ósemkowym, szesnastkowym i binarnym systemie liczbowym. x = 0x1 # szesnastkowy y = 0o1 # ósemkowy z = 0b1 # binarny print(type(x), x) print(type(y), y) print(type(z), z) ## &lt;class &#39;int&#39;&gt; 1 ## &lt;class &#39;int&#39;&gt; 1 ## &lt;class &#39;int&#39;&gt; 1 Jest także float - typ liczb zmiennoprzecinkowych. x = 0.5 y = -0.5 print(type(x), x) print(type(y), y) ## &lt;class &#39;float&#39;&gt; 0.5 ## &lt;class &#39;float&#39;&gt; -0.5 x = 0.1 + 0.1 y = 0.1 + 0.1 + 0.1 z = 0.3 s = 0.2 print(x == s) print(&quot;{:.20f}&quot;.format(x) ) print(&quot;{:.20f}&quot;.format(s)) print(y == z) print(&quot;{:.20f}&quot;.format(y)) print(&quot;{:.20f}&quot;.format(z)) ## True ## 0.20000000000000001110 ## 0.20000000000000001110 ## False ## 0.30000000000000004441 ## 0.29999999999999998890 W celu przechowywania ciągu znaków używamy typu string. a = &#39;A wewnątrz można umieścić &quot;cudzysłów&quot;&#39; b = &quot;A wewnątrz można umieścić &#39;apostrof&#39;&quot; Trzy pojedyncze apostrofy są wygodne do zapisania tekstu w kilku linijkach. c = &#39;&#39;&#39;Trzy pojedyncze apostrofy&#39;&#39;&#39; W celu dokumentacji używamy trzech cudzysłowów. d = &quot;&quot;&quot;Trzy cudzysłowy&quot;&quot;&quot; Żeby odwołać się do poszczególnych części słowa indeksujemy. a = &#39;Laura jadła jabłko&#39; print(type(a), a) print(&#39;len(a): &#39;, len(a)) # sprawdzanie długości słowa print(type(a[0]), &#39;a[0]: &#39;, a[0]) # pierwszy element ma indeks 0 print(&#39;a[1]: &#39;, a[1]) print(&#39;a[len(a) - 1]: &#39;, a[len(a) - 1]) # ostatni element to długość - 1, ponieważ indeksujemy od 0 print(&#39;a[-1] = a[len(a) - 1]: &#39;, a[-1]) # indeksy ujemne liczą od ostatniego znaku print(&#39;a[-18] = a[0]: &#39;, a[-18]) ## &lt;class &#39;str&#39;&gt; Laura jadła jabłko ## len(a): 20 ## &lt;class &#39;str&#39;&gt; a[0]: L ## a[1]: a ## a[len(a) - 1]: o ## a[-1] = a[len(a) - 1]: o ## a[-18] = a[0]: u a = &#39;Laura jadła jabłko&#39; b = a print(id(a), a) print(id(b), b) a += &#39;!&#39; print(id(a), a) print(id(b), b) ## 2057059081392 Laura jadła jabłko ## 2057059081392 Laura jadła jabłko ## 2057060425904 Laura jadła jabłko! ## 2057059081392 Laura jadła jabłko Do zastanowienia… Co znaczy, że język jest dynamicznie typowany? Co znaczy, że język jest interpretowany? Podaj przykłady Jak sprawdzić, czy wartość należy do jakiejś klasy? Jak sprawdzić długość string? Jak napisać wiersz w Pythonie? 2.2.2 Struktury danych W zależności od zadania i problemu nasze dane chcemy przechowywać w przeznaczony do tego sposób - w tym celu używamy właśnie tzw. struktur danych. Jedną z najprostszych jest lista - zezwala ona na przechowywanie elementów o różnych typach i swobodne odwołanie się do nich, a także łatwe dodawanie i usuwanie wartości. s = [] # pusta lista print(s) print(type(s)) print(&quot;len:&quot;,len(s)) l = [1, 2, 3, 5, 7] # lista elementów typu int print(l) print(len(l)) a = [0] * 10 # lista o danym rozmiarze print(a) print(len(a)) ## [] ## &lt;class &#39;list&#39;&gt; ## len: 0 ## [1, 2, 3, 5, 7] ## 5 ## [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ## 10 Lista jest także obiektem iterowalnym - oznacza to, że jest przystosowana do “lecenia element po elemencie.” b = list(&#39;lista&#39;) print(b) print(len(b)) mix = [7,&#39;👻&#39;,&#39;róża&#39;, 3 + 2j] # w listach może być &quot;wszystko&quot; print(mix) print(len(mix)) print(type(mix[1]), mix[1]) # indeksujemy ## [&#39;l&#39;, &#39;i&#39;, &#39;s&#39;, &#39;t&#39;, &#39;a&#39;] ## 5 ## [7, &#39;👻&#39;, &#39;róża&#39;, (3+2j)] ## 4 ## &lt;class &#39;str&#39;&gt; 👻 Warto przyjrzeć sie liście także patrząc na różnicę mutable vs. immutable. m = [1, 2, 3] n = m print(id(m), m) print(id(n), n) m.append(&quot;słoń&quot;) print(id(m), m) print(id(n), n) ## 1700060090760 [1, 2, 3] ## 1700060090760 [1, 2, 3] ## 1700060090760 [1, 2, 3, &#39;słoń&#39;] ## 1700060090760 [1, 2, 3, &#39;słoń&#39;] Przydaje się funkcja copy()… bez zaskoczeń tworząca kopię danego obiektu. l = [1, 2, 3, 5, 7] more_lists = l[:] #slices more_list2 = l.copy() print(id(l), l) print(id(more_lists), more_lists) print(id(more_list2), more_list2) ## 1443558805896 [1, 2, 3, 5, 7] ## 1443558806408 [1, 2, 3, 5, 7] ## 1443560837832 [1, 2, 3, 5, 7] Bardzo przydatną umiejętnością jest zaznajomienie z obiektem slice (pl: wykrojenie?). Służy on do wygodnego tworzenia ciągów arytmetycznych, a także indeksowania po utworzonych sekwencjach. Składnia slice() to slice(start, stop, step). l = [1, 2, 3, 5, 7] sl = slice(2, 5, 1) print(type(sl), sl) print(l[sl]) print(l[2:5:1]) print(l) ## &lt;class &#39;slice&#39;&gt; slice(2, 5, 1) ## [3, 5, 7] ## [3, 5, 7] ## [1, 2, 3, 5, 7] Abstrahując od wykrojeń, generalnie odwoływanie się do różnych elementów listy w zależności od potrzeb niemalże zawsze jest bardzo proste i łatwe do napisania - przyjrzyjmy się poniższym przykładom. lis = [1, 2, 3, 5, 7] print(lis[-1]) # ostatni element print(lis[-1:]) # ostatni element, ale ... print(lis[::-1]) # odwrotna kolejność print(lis[::2]) # elelemty z indeksami parzystymi print(lis[:-2]) # cała sekwencja poza ostatnimi dwoma elementami print(lis[1::2]) # elementy z indeksami nieparzystymi ## 7 ## [7] ## [7, 5, 3, 2, 1] ## [1, 3, 7] ## [1, 2, 3] ## [2, 5] Na pozornie podobnej zasadzie jak slice działa range. Ten może przyjąć jeden, dwa lub trzy parametry: range(stop) range(start, stop) range(start, stop, step) Przyjrzyj się kolejnym wywołaniom i pomyśl: czym rożnią się slice i range? range_ = range(20) print(type(range_),range_) a = list(range(20)) b = [range(10, 20, 1)] c = list(range(10, 20, 1)) print(&quot;a:&quot;, a) print(&quot;b:&quot;, b) print(&quot;c:&quot;, c) ## &lt;class &#39;range&#39;&gt; range(0, 20) ## a: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] ## b: [range(10, 20)] ## c: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] Sprawdź się! Stwórz listę liczb od 0 do 500 Policz sumę wszystkich elementów tej listy Odwróć tę listę Dodaj na początek słowo PoweR Stwórz listę parzystych liczb o długości 50 Dla stringa “PoweR warsztaty i przygoda!”, usuń wszystkie litery z 6 znaku aż do końca, wyświetl otrzymany string (oczekiwana wartość: “PoweR”) Mamy 2 stringi - s1 i s2. Stwórz nowy string dodając s2 w środku s1. Przykładowo: Przed: “Supplementary” i “Vector” Po: “SupplVectorementary” Policz liczbę wystąpień litery e w stringu “PoweR is the best event evER” nie patrząc na wielkość litery (oczekiwana wartość: 7) … Jedną z naistotniejszych struktur danych w Pythonie są tuple, zwane także krotkami. a = () # pusta tuple print(type(a), a) a = (1,2,3,4) # deklaracja print(type(a), a) a = 1,2,3,4 # inna deklaracja print(type(a), a) a = (1) # ważne są przecinki, a nie nawiasy print(type(a), a) a = 1, # tuple z 1 elementem print(type(a), a) n_tuple = (&quot;mouse&quot;, [8, 4, 6], (1, 2, 3)) print(type(n_tuple), n_tuple) ## &lt;class &#39;tuple&#39;&gt; () ## &lt;class &#39;tuple&#39;&gt; (1, 2, 3, 4) ## &lt;class &#39;tuple&#39;&gt; (1, 2, 3, 4) ## &lt;class &#39;int&#39;&gt; 1 ## &lt;class &#39;tuple&#39;&gt; (1,) ## &lt;class &#39;tuple&#39;&gt; (&#39;mouse&#39;, [8, 4, 6], (1, 2, 3)) Kolejną ważną strukturą są słowniki - ich idea to przechowywania wartości pod odpowiednimi kluczami. Należy pamiętać, że klucz jest tylko obiektem immutable (hashowalnym) i jeden klucz może mieć tylko jedną wartość (jeżeli będzie dodane kilka par z tym samym kluczem, Python zapisze ostatni). Protip: jeśli chcesz zapisać kolejność, w której elementy zostały dodane do słownika, użyj funkcji collections.OrderedDict(). a = dict() # pusty słownik b = {} # alternatywa na deklaracje pustego słownika c = {&#39;klucz&#39;: &#39;wartość&#39;} print(type(a), a) print(type(b), b) print(type(c), c) a[&#39;new_key&#39;] = &#39;new_value&#39; # Dodajemy nowy element do słownika a[(7, 8)] = [(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;),&#39;🤖&#39;] print(a) a[&#39;new_key&#39;] = &#39;👧&#39; print(a) ## &lt;class &#39;dict&#39;&gt; {} ## &lt;class &#39;dict&#39;&gt; {} ## &lt;class &#39;dict&#39;&gt; {&#39;klucz&#39;: &#39;wartość&#39;} ## {&#39;new_key&#39;: &#39;new_value&#39;, (7, 8): [(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), &#39;🤖&#39;]} ## {&#39;new_key&#39;: &#39;👧&#39;, (7, 8): [(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), &#39;🤖&#39;]} Jeśli klucz nie występuje w słowniku, pojawia się error. Żeby tak nie było trzeba dodatkowo zdefiniować zachowanie __missing__(key). Poniższe operacje nie zadziałają poprawnie. print(c[&#39;nieklucz&#39;]) a[[1, 2]] = &#39;nie działa&#39; Do przechowywania wartości unikalnych, przyda nam sie set - zbiór. Najprościej mówiąc jest to „kontener” zawierający niepowtarzalne elementy w losowej kolejności. Czas sprawdzenia czy jakiś obiekt jest w zbiorze jest stały, w porównaniu do listy albo krotki, w których czas jest liniowo zależny od liczby elementów. a = set() print(type(a), a) a = {} # nie set , a ... print(type(a), a) a = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;} print(type(a), a) mixed_set = {2.0, &quot;Nicholas&quot;, (1, 2, 3)} print(type(mixed_set), mixed_set) mixed_set.add(&quot;Katty&quot;) print(type(mixed_set), mixed_set) Jeżeli chcielibyśmy dodać do zbioru element już w nim będący - set go zignoruje. a = {[1,2,3], [1,2,3]} 2.2.3 Operatory W celu wykonania operacji arytmetycznych i dokonania innych ingerencji między obiektami, składnia jest prosta i nieodbiegająca od standardu innych języków programowania. Arytmetyczne: + dodawanie - odejmowanie * mnożenie ** potęgowanie / dzielenie -&gt; float // dzielenie z zaokrągleniem do najbliższego int w dół % reszta z dzielenia Porównania: == równe co do wartości != różne co do wartości is zwraca true, jeśli obie zmienne są tym samym obiektem (porównuje wyniki funkcji id, adresy obiektów przechowywane w pamięci) is not zwraca true, jeśli obie zmienne nie są tym samym obiektem &lt; mniejsze &gt; większe &gt;= większe lub równe &lt;= mniejsze lub równe in zwraca wartość True, jeśli w obiekcie znajduje się sekwencja o określonej wartości (np litera w stringu) not in czy obiekt nie jest zawarty w innym obiekcie Logiczne: and zwraca wartość True, jeśli obie instrukcje są prawdziwe (x &lt; 5 and x &lt; 10) or zwraca wartość True, jeśli jedno z wyrażeń jest prawdziwe (x &lt; 5 or x &lt; 4) not odwraca wynik, zwraca False, jeśli wynik jest prawdziwy (x &lt; 5 and x &lt; 10) Trochę o operatorze in: 1. W listach są przeszukiwane wszystkie elementy po kolei. Czas wyszukiwania zależy od rozmiaru listy. 2. Dla zbiorów wyszukiwanie nie zależy od rozmiaru zbioru - jest stałe 3. W przypadku słowników wyszukiwane są tylko klucze, czas wyszukiwania nie zależy od liczby elementów w słowniku. Średnio O(1) Uwaga! Do porównywania stosujemy tylko ==. Jest to bardzo ważne, gdyż niedbałe mylenie == z = to typowy błąd początkujących programistów, który niezwykle często doprowadza do nieporozumień i zepsucia działania kodu tylko przez tą jedną literkę, którą niekiedy i wychwycić niełatwo. Zobaczmy nasze oparatory w akcji. x = 256 y = 256 print(&#39;id(x)&#39;, id(x)) print(&#39;id(y)&#39;, id(y)) print(&#39;x is y&#39;, x is x) print(&#39;x == y&#39;, x == y) x = 257 y = 257 print(&#39;id(x)&#39;, id(x)) print(&#39;id(y)&#39;, id(y)) print(&#39;x is y&#39;, x is y) print(&#39;x == y&#39;, x == y) ## id(x) 140726998450544 ## id(y) 140726998450544 ## x is y True ## x == y True ## id(x) 2751384603344 ## id(y) 2751384603344 ## x is y True ## x == y True Zwróć uwagę, jak zmieniło się zachowanie Pythona dla operatorów == i is - dzieje się tak dlatego, że zwzględów optymalizacyjnych liczby “małe” są nieco inaczej interpretowane. 2.2.4 Instrukcja warunkowa … to element języka pozwalający na wybór różnych ścieżek operacji w zależności od spełnionych warunków. Kluczowa jest umiejętność użytku i rozumienia instrukcji if, else i elif (skrót od else if). Działają one niemalże tak, jak można by się spodziewać po ich tłumaczeniach. x = 10 print(&#39;przed ifem&#39;) if x == 10: print(&#39;x=10&#39;) elif x == 4: print(&#39;x=4&#39;) elif x == 5: print(&#39;x=5&#39;) else: print(&#39;else&#39;) print(&#39;po ifie&#39;) ## przed ifem ## x=10 ## po ifie 2.2.5 Pętle W celu wykonania danego bloku operacji wiele razy korzystamy z pętli. Tak jak i w przypadku innych popularnych języków programowania, kluczowa jest znajomość for i while. Na tą pierwszą najwygodniej patrzeć jak na pętlę “dla każdego…”. Oto jej działanie: for number in range(5): print(number) ## 0 ## 1 ## 2 ## 3 ## 4 Iterować możemy po po dowolnych iterowalnych obiektach. mix = [7,&#39;👻&#39;,&#39;róża&#39;, 3 + 2j] for el in mix: print(el) for i in &#39;hello world&#39;: print(i * 2, end = &#39;&#39;) ## 7 ## 👻 ## róża ## (3+2j) ## hheelllloo wwoorrlldd W celu przerwania działania pętli korzystamy z instrukcji break, zaś kiedy chcemy rozpocząć następny obrót pętli, omijając pozostałą część - używamy continue. for i in &#39;hello world&#39;: if i == &#39;e&#39;: break print(i * 2, end = &#39;&#39;) ## hh for i in &#39;hello world&#39;: if i == &#39;o&#39;: continue print(i * 2, end = &#39;&#39;) ## hheellll wwrrlldd Przydatna jest też operacja else dla pętli - wykona się ona, jeśli pętla zakończyła się normalnie (nie za pomocą break). for i in &#39;hello world&#39;: if i == &#39;a&#39;: break else: print(&#39;Nie ma takiej litery&#39;) ## Nie ma takiej litery Drugą pętlą jakiej możemy użyć w Pythonie jest while - zezwala ona na wykonywanie operacji w bloku kodu jej przeznaczonym tak długo, aż wpisany przez programistę warunek będzie spełniony. Intuicja: while to taki if wykonywany wielokrotnie. i = 5 while i &lt; 15: print(i) i = i + 2 ## 5 ## 7 ## 9 ## 11 ## 13 Rezultaty pętli for możemy także zapisywać w taki oto skrótowy sposób: squares = [] for x in range(10): squares.append(x ** 2) print(squares) squares = [x**2 for x in range(10)] print (squares) b = [x for x in range(10) if not x%3] # lista liczb podzielnych przez 3 and &lt; 10 print(b) ## [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] ## [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] ## [0, 3, 6, 9] Można także składać zbiory i słowniki. a = {str(i):i for i in [1,2,3,4,5]} # słownik print(a) a = {x for x in range(10) } # set print(a) ## {&#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5} ## {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} … oraz tuple. Tylko uważaj! a = (x for x in range(10)) # generatory print(type(a)) print(next(a)) print(next(a)) b = tuple(x for x in range(10)) # tuple print(type(b)) ## &lt;class &#39;generator&#39;&gt; ## 0 ## 1 ## &lt;class &#39;tuple&#39;&gt; Sprawdź się! Mamy 2 listy. Wypisz True jeśli pierwszy i ostatni element na liście jest taki sam Zrób listę od 1 do 100 i wypisz wszystkie liczby podzielne przez 5 Wypisz taką piramidę 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 (Pamiętaj o print (…, end=&quot; &quot;)) Połącz dwie listy tak, że do wynikowej listy z pierwszej będą liczby nie parzyste, a z drugiej parzyste. Przykładowo: list1 = [15, 22, 23, 17, 19] list2 = [24, 43, 24, 36, 11] Merged List is [15, 23, 17, 19, 24, 24, 36] Policz wystąpienia kolejnych elementów i na podstawie tego stwórz słownik. Przykładowo: list1 = [121, 43, 87, 121, 23, 43, 43, 43, 87] dict1 = {121: 2, 43: 4, 87: 2, 23: 1} Rozpakuj krotkę do wartości Zamień wszystkie ostatnie wartości w tuple na 99. Przykładowo: l1 = [(10, 20, 40), (40, 50, 60), (70, 80, 90)] result = [(10, 20, 99), (40, 50, 99), (70, 80, 99)] Mamy listę mix[string, int , float …]. Stwórz nową listę która będzie miała tylko int. 2.2.6 Funkcje W Pythonie definiuje się je za pomocą słowa kluczowego def: def func(): print(&quot;Hi, dear!&quot;) func() ## Hi, dear! W zależności od deklaracji, funkcja może przyjąć dowolną liczbę argumentów o niemalże ograniczonej swobodzie wyboru typów. def greet(name): &quot;&quot;&quot;This function greets to the person passed in as parameter&quot;&quot;&quot; print(&quot;Hello, &quot; + name + &quot;. Good morning!&quot;) print(greet.__doc__) greet(&quot;Kate&quot;) ## This function greets to the person passed in as parameter ## Hello, Kate. Good morning! W przypadku podawania argumentów pozycyjnie, podaje się je po nazwie funkcji w nawiasach. Możesz dodać dowolną liczbę argumentów - po prostu oddziel je przecinkiem. def func(name): return name + &quot; Ref&quot; a = func(&quot;Katty&quot;) print(a) print(func(&quot;Lila&quot;)) print(func(&quot;Ewa&quot;)) ## Katty Ref ## Lila Ref ## Ewa Ref Można też podawać argumenty kluczowo, tj. przez nazwanie. Wtedy kolejność jest nieważna. def func(person3, person2, person1): print(&quot;Imie ryczerza to &quot; + person3) func(person1 = &quot;Emil&quot;, person2 = &quot;Tobias&quot;, person3 = &quot;Linus&quot;) ## Imie ryczerza to Linus def func(x = 1, y = 1): outcome = x + y print(outcome) func(x = 100) ## 101 Uwaga z kolejnością argumentów z wartościami default! Deklaracja poniższej funkcji nie będzie poprawna. def greet(msg = &quot;Good morning!&quot;, name): pass Można za to napisać w taki sposób: def gree(name, msg = &quot;Good morming!&quot;): pass Python daje także możliwość użycia Args - arbitrary arguments. Jeśli nie wiesz, ile argumentów zostanie przekazanych do funkcji, dodaj gwiazdkę przed nazwą parametru w definicji funkcji. def func(*args): print(type(args)) print(&quot;Imie ryczerza to &quot; + args[2]) func(&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;) ## &lt;class &#39;tuple&#39;&gt; ## Imie ryczerza to Linus Są także i Kwargs - arbitrary keyword arguments. Jeśli nie wiesz, ile argumentów nazwanych zostanie przekazanych do funkcji, dodaj dwie gwiazdki przed nazwą parametru w definicji funkcji. def func_kwargs(**places): print(&quot;Jestem z &quot; + places[&quot;region&quot;] + &quot; województwa&quot;) func_kwargs(city = &quot;Warszawa&quot;, region = &quot;Łódzkiego&quot;) Pamiętajmy o Mutable vs. Immutable! Poniżej niepoprawnie zadeklarowana funkcja i tego efekty: def printing(lista = []): lista.append(&#39;print&#39;) for el in lista: print(id(lista), el) printing() li = [&#39;nowe słowo&#39;] print(id(li)) printing(li) printing() ## 2549309919624 print ## 2549340382792 ## 2549340382792 nowe słowo ## 2549340382792 print ## 2549309919624 print ## 2549309919624 print Niżej już poprawna implementacja i jej wywołanie: def printing(lista = None): print(&quot;Przed if: &quot;,id(lista)) lista = lista if lista else [] # druga opcja lista or [] print(&quot;Po if: &quot;, id(lista)) lista.append(&#39;print&#39;) for el in lista: print(id(lista), el) printing() printing() l = [&#39;nowe słowo&#39;] print(&quot;Przed wywołaniem funkcji: &quot;, id(l)) printing(l) ## Przed if: 140726997966048 ## Po if: 2547467965320 ## 2547467965320 print ## Przed if: 140726997966048 ## Po if: 2547467965320 ## 2547467965320 print ## Przed wywołaniem funkcji: 2547467965320 ## Przed if: 2547467965320 ## Po if: 2547467965320 ## 2547467965320 nowe słowo ## 2547467965320 print Sprawdź się! Napisz program, który znajdzie wszystkie takie liczby, które są podzielne przez 7, ale nie są wielokrotnością 5, od 2000 do 3200 (włącznie). Otrzymane liczby należy wydrukować w oddzielonej przecinkami sekwencji w jednym wierszu. Napisz funkcję, która oblicza i drukuje wartość zgodnie z podaną formułą: Q = (2 * C * D) / H, gdzie: C - argument nienazwany - integer D - argument nienazwany - integer H - nie wiadomo ile jest argumentów nienazwanych (jeżeli więcej niż 1 to zsumować H1 + H2 + H3) Zrób funkcję, przyjmującą listę tuple, indeks(“i”) i wartość(“w”). Zamień wszystkie wartości na indeksie “i” w tuple na wartość (“w”). Przykładowo: l1 = [(10, 20, 40), (40, 50, 60), (70, 80, 90)] change(l1,1,77) result = [(10, 77, 40), (40, 77, 60), (70, 77, 90)] 2.2.7 Ramka danych i pandas - mały wstęp W kolejnych krokach będziemy brać pod lupę dwa rodzaje tabel: Series - jest to jednowymiarowa struktura danych („jednowymiarowa tablica”), która może przechowywać wartości i dla każdej wartości ma także unikalny indeks DataFrame - dwuwymiarowa (lub więcej) wymiarowa struktura danych - w zasadzie tabela z wierszami i kolumnami. Kolumny mają nazwy, a wiersze indeksy. Pandas to doskonała biblioteka implementująca wiele przydatnych narzedzi do obróbki i pracy nad ramką danych. Aby móc korzystać z jej mocy, musimy wczytać (i ewentualnie zainstalować, jeżeli nie zostało to wcześniej zrobione) pakiet o tej właśnie nazwie. Standardowo przyjęło się wczytywać go jako pd - dodanie do instrukcji wczytywania biblioteki magicznych czterech liter as pd zezwoli nam na możliwość odwoływania sie w każdym kolejnym kroku kiedy będziemy potrzebować pandas nie do całej sześcioliterowej nazwy pakietu, ale tylko do tych dwóch prostych znaków. Jeżeli nie masz jeszcze zainstalowanego pakietu pandas - użyj instrukcji jak niżej… a następnie za każdym razem gdy będziesz potrzebować jego dóbr - wczytaj go za pomocą instrukcji import. install.packages(&quot;pandas&quot;) import pandas as pd Dzięki pandas możemy łatwo wczytywać gotowe pliki .csv. Instrukcja read_csv() standardowo przyjmuje dwa argumenty - ścieżkę do pliku i opcjonalnie delimiter - sposób, w jaki oddzielone są kolejne wartości w wierszach. data = pd.read_csv(&quot;files/movies.csv&quot;, delimiter = &#39;,&#39;) Tak utworzona ramka danych ma swój własny typ. print(type(data.head())) Możemy łatwo odwołać się do pierwszych lub ostatnich wierszy data frame za pomocą metod head() i tail(). display(data.tail()) display(data.head()) Do zwrócenia losowych rows używamy sample(). data.sample(5) Możemy także łatwo odwołać się do wierszy spełniających podane kryteria. Przykładowo poniższa instrukcja zwróci nam te, dla których wartość odpowiadająca za title przyjmuje &quot;Apaches*. data[data.title == &quot;Apaches&quot;] Sprawdź się! Sprawdź szczegółowe informacje o DataFrame Uzyskaj pierwsze 3 wiersze danych Wyświetl kolumny title i description Wyświetl kolumny show_id, country, data_added dla wierszy 0, 3, 6, 24 Wyświetl wiersze gdzie release_year &gt; 2010 Wyświetl wiersze, gdzie director is NaN Policz ile jest takich wierszy jak w punkcie 5. Sprawdź typ kolumny duration Sprawdź co to znaczy Zmień nazwę kolumny title na name Dodaj nowy wiersz "],
["formatowanie-danych.html", " 3 Formatowanie danych", " 3 Formatowanie danych Formatowanie danych pandas, numpy (Python) dplyr, tidyr (R) "],
["wizualne-eda.html", " 4 Wizualne EDA", " 4 Wizualne EDA "]
]
