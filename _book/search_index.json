[
["podstawy-jezyka.html", " 2 Podstawy jÄ™zyka 2.1 R 2.2 Python", " 2 Podstawy jÄ™zyka WstÄ™p do Pythona i R 2.1 R 2.1.1 Podstawowe operacje NastÄ™pujÄ…cy kod bÄ™dzie pisany w oprogramowaniu RStudio. Jest to najbardziej powszechne Å›rodowisko programistyczne R-a, integrujÄ…ce takÅ¼e wiele innych przydatnych funkcjonalnoÅ›ci. R to bardzo wygodne narzÄ™dzie w kwestii operacji arytmetycznych. SprawdÅºmy jak sprawdzi siÄ™ dla paru z nich! 2 + 2 ## [1] 4 2 + 2 + 2 + 2 ## [1] 8 2^4 ## [1] 16 OprÃ³cz wyÅ¼ej wymienionych moÅ¼na takÅ¼e dokonywaÄ‡ wielu innych obliczeÅ„. Zachowywana jest takÅ¼e kolejnoÅ›Ä‡ dziaÅ‚aÅ„. Zadanie 1 SprawdÅº czy R zachowuje kolejnoÅ›Ä‡ dzialaÅ„. Jakiego przykladu moÅ¼na uzyÄ‡? PrzykÅ‚adowe rozwiÄ…zanie: 2 + 2 * 2 ## [1] 6 W R-rze istniejÄ… dwie metody przypisania. GÅ‚ownie uÅ¼ywamy skÅ‚adni x &lt;- 5 (moÅ¼liwe takÅ¼e 5 -&gt; x), ale istnieje rownieÅ¼ opcja moÅ¼e bardziej instynktownego x = 5. Standardowo przynajmniej na tym etapie lepiej jest jednak uÅ¼ywaÄ‡ â€œstrzaÅ‚kiâ€. x &lt;- 5 x ## [1] 5 y = 5 zmienna &lt;- &quot;Hello World!&quot; 2.1.2 Struktury danych JednÄ… z podstawowych sÄ… wektory. SÅ‚uÅ¼Ä… one do przechowywania pewnej liczby elementÃ³w w jednej zmiennej. parzyste &lt;- c(2, 4, 6) litery &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) litery[2] ## [1] &quot;b&quot; vec &lt;- c(parzyste, litery) vec ## [1] &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; OczywiÅ›cie i na nich moÅ¼emy dokonywaÄ‡ rÃ³Å¼nych operacji. nieparzyste &lt;- c(1, 3, 5) parzyste + nieparzyste ## [1] 3 7 11 parzyste * x ## [1] 10 20 30 InnÄ… istotnÄ… strukturÄ… sÄ… listy. liczby &lt;- list(parzyste = parzyste, nieparzyste = nieparzyste) c(parzyste, nieparzyste) ## [1] 2 4 6 1 3 5 liczby[[1]] ## [1] 2 4 6 liczby[[&quot;parzyste&quot;]] ## [1] 2 4 6 Zadanie 2 StwÃ³rz dwa wektory skÅ‚adajÄ…ce siÄ™ z 5 liczb kaÅ¼dy, a nastÄ™pnie przypisz ich roÅ¼nice do nowej zmiennej o nazwie rÃ³Å¼nica. PoÅ‚Ä…cz te trzy wektory w listÄ™. PrzykÅ‚adowe rozwiÄ…zanie: a &lt;- c(1, 2, 3, 4, 5) b &lt;- c(6, 7, 8, 9, 10) roznica &lt;- b - a lista_wektorow &lt;- list(a, b, roznica) R jest takÅ¼e bogaty w szereg przydatnych funkcji wbudowanych. Oto niektÃ³re z nich i ich dziaÅ‚anie: ?min # zwraca informacje o funkcji min(roznica) ## [1] 5 max(roznica) ## [1] 5 sum(roznica) ## [1] 25 length(roznica) ## [1] 5 vec2 &lt;- 1:20 vec2 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 vec3 &lt;- 50:100 vec3 ## [1] 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 ## [18] 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 ## [35] 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 KolejnÄ… bardzo waÅ¼nÄ… strukturÄ… w R jest ramka danych. df &lt;- data.frame(col_1 = c(1, 2, 3), col_2 = c(&quot;raz&quot;, &quot;dwa&quot;, &quot;trzy&quot;)) MoÅ¼emy na niej dziaÅ‚aÄ‡ poprzez odpowiednie operatory: df$col_1 ## [1] 1 2 3 df[[&quot;col_1&quot;]] ## [1] 1 2 3 df[3, 1] ## [1] 3 df[,1] ## [1] 1 2 3 df[1,] ## col_1 col_2 ## 1 1 raz df[2:3,] ## col_1 col_2 ## 2 2 dwa ## 3 3 trzy 2.1.3 Instrukcja warunkowa â€¦ to konstrukcja, ktÃ³rej uÅ¼ywamy W celu dokonywania decyzji o wykonywanych krokach. NajproÅ›ciej mÃ³wiÄ…c owy element jÄ™zyka pozwala na wykonanie ciÄ…gu operacji w zaleÅ¼noÅ›ci od zaproponowanego przez programistÄ™ warunku. Oto i przykÅ‚adowe takie warunki: 1 == 1 ## [1] TRUE 1 == 0 ## [1] FALSE 1 &gt; 0 ## [1] TRUE 1 &lt; 0 ## [1] FALSE !(1==1) ## [1] FALSE parzyste ## [1] 2 4 6 parzyste == 2 ## [1] TRUE FALSE FALSE all(parzyste == 2) ## [1] FALSE any(parzyste == 2) ## [1] TRUE 2 %in% parzyste ## [1] TRUE â€¦ i sama instrukcja if w praktyce: if( !(8 %in% parzyste) ){ parzyste &lt;- c(parzyste, 8) } parzyste ## [1] 2 4 6 8 skorupa &lt;- TRUE if(skorupa == TRUE){ &quot;zolw&quot; } else { &quot;kot&quot; } ## [1] &quot;zolw&quot; ifelse(skorupa == TRUE, &quot;zolw&quot;, &quot;kot&quot;) ## [1] &quot;zolw&quot; ifelse dziaÅ‚a teÅ¼ na wektorze: skorupa &lt;- c(TRUE, TRUE, FALSE) ifelse(skorupa == TRUE, &quot;zolw&quot;, &quot;kot&quot;) ## [1] &quot;zolw&quot; &quot;zolw&quot; &quot;kot&quot; Zadanie 3 Podobnie jak w powyÅ¼szym przykÅ‚adzie, wektor liczb nieparzystych powiÄ™ksz o liczbe 7, o ile juÅ¼ jej nie ma. Dany jest wektor liczb, v &lt;- c(1,2,2,2,2,2,3,3,3,1,1,2). UÅ¼yj instrukcji if else lub ifelse, zeby zrobiÄ‡ z niego wektor zawierajÄ…cy wartosci â€œjedenâ€, â€œdwaâ€, â€œtrzyâ€. PrzykÅ‚adowe rozwiÄ…zanie: if( !(7 %in% nieparzyste) ){ nieparzyste &lt;- c(nieparzyste, 7) } nieparzyste ## [1] 1 3 5 7 v &lt;- 2 ifelse(v == 1, &quot;jeden&quot;, ifelse(v == 2, &quot;dwa&quot;, &quot;trzy&quot;)) ## [1] &quot;dwa&quot; 2.1.4 PÄ™tle CzÄ™sto spotykamy siÄ™ z sytuacjÄ…, kiedy danÄ… operacjÄ™ lub ciÄ…g wielu instrukcji chcemy wykonaÄ‡ wielokrotnie. Do tego wÅ‚aÅ›nie uÅ¼ywamy tytuÅ‚owych konstrukcji. Dwie najbardziej powszechne to while i for. Pierwsza z nich dziaÅ‚a na podobnej zasadzie jak intrukcja if - z tym wyjÄ…tkiem, Å¼e warunek sprawdzany jest wielokrotnie - tak dÅ‚ugo, aÅ¼ bÄ™dzie speÅ‚niany. while (length(parzyste) &lt; 10) { len &lt;- length(parzyste) parzyste &lt;- c(parzyste, parzyste[len] + 2) } Z drugiej strony for udostÄ™pnia nam moÅ¼liwoÅ›Ä‡ wykonania operacji konkretnÄ… iloÅ›Ä‡ razy - np. dokonujÄ…c czynnoÅ›ci dla kaÅ¼dej liczby z listy. nieparzyste2 &lt;- c() for(liczba in parzyste){ nieparzyste2 &lt;- c(nieparzyste2, liczba - 1) } Zadanie 4 UÅ¼yj pÄ™tli (ktÃ³rej?), Å¼eby iterujÄ…c po wektorze liczby &lt;- 1:10 stworzyÄ‡ wektor 10 kolejnych liczb nieparzystych. Czy jest wiÄ™cej niÅ¼ jeden sposob? PrzykÅ‚adowe rozwiÄ…zanie: a) nieparzyste3 &lt;- c() for(x in 1:10){ nieparzyste3 &lt;- c(nieparzyste3, 2 * x - 1) } AleÅ¼ oczywiÅ›cie, Å¼e tak! 2.1.5 Pliki i odczyt danych Bardzo istotnymi funkcjami sÄ… getwd() i setwd() - pierwsza zwraca Å›cieÅ¼kÄ™ do roboczego katalogu roboczego, zaÅ› druga umoÅ¼liwia ustawienie nowej. getwd() setwd(&quot;/Users/ja/mojeskrypty&quot;) Do odczytania ramki danych moÅ¼emy uÅ¼yÄ‡ funkcji read.csv - w tym celu jako pierwszy argument podajemy Å›cieÅ¼kÄ™ do naszego pliku, a jako opcjonalny drugi - separator [znak lub ciÄ…g oddzielajÄ…cy kolejne kolumki data frame]. # seriale &lt;- read.csv(&quot;&lt;tu nalezy wkleic sciezke do pliku&gt;&quot;, sep=&quot;;&quot;) seriale &lt;- read.csv(&quot;files/netflix_titles.csv&quot;) Zobaczmy efekt wywoÅ‚ania naszej funkcji - operacja head zwrÃ³ci nam kilka pierwszych wierszy, zaÅ› View udostÄ™pnia estetyczny oglÄ…d tabelki. head(seriale) View(seriale) Zadanie 5 Wypisz nazwy seriali, ktÃ³re wyszÅ‚y w 2020 roku. Wybierz podzbiÃ³r zawierajÄ…cy Twoje 3 ulubione seriale i przypisz go do nowej zmiennej. PrzykÅ‚adowe rozwiÄ…zanie: a) Tworzymy wektor, ktÃ³ry odpowiada kolejnym wierszom z ramki danych, jeÅ›li zawiera TRUE, to znaczy, Å¼e serial byÅ‚ wydany w 2020, jeÅ›li FALSE oznacza, Å¼e serial byl wydany w innym roku ktore_w_2020 &lt;- seriale[[&quot;release_year&quot;]] == 2020 MoÅ¼emy uÅ¼yc wektora TRUE/FALSE do indeksowania wierszy. PoniÅ¼sze polecenie wybierze tylko te wiersze, w ktÃ³rych wektor ktore_w_2020 przyjÄ…Å‚ wartoÅ›Ä‡ TRUE. seriale_2020 &lt;- seriale[ktore_w_2020, ] moje_seriale &lt;- seriale[c(1, 2, 10), ] 2.2 Python 2.2.1 Podstawy i proste typy print(&quot;Hi!&quot;) ## Hi! Python jest jÄ™zykiem interpretowanym - najproÅ›ciej mÃ³wiÄ…c oznacza to, Å¼e jest on tÅ‚umaczony i wykonywany â€œw locieâ€. TÅ‚umaczeniem i wykonywaniem programu zajmuje siÄ™ specjalny program nazwany interpreterem jÄ™zyka. Najprostszym typem jest int - obejmuje on liczby caÅ‚kowite. x = 21 print(x) print(type(x)) y = 0.3 print(y) print(type(y)) ## 21 ## &lt;class &#39;int&#39;&gt; ## 0.3 ## &lt;class &#39;float&#39;&gt; def fun(x, y): return x + y x = &quot;Data&quot; y = &quot;Science&quot; print(fun(x, y)) x = 5 y = 7 print(fun(x, y)) ## DataScience ## 12 Python jest dynamicznie typowany i typowanie jest silne - oznacza to, Å¼e jÄ™zyk nie moÅ¼e niejawnie konwertowaÄ‡ wartoÅ›ci rÃ³Å¼nych typÃ³w. a = 2 b = &#39;L&#39; c = a + b # zwrÃ³ci bÅ‚Ä…d WartoÅ›ci niektÃ³rych obiektÃ³w mogÄ… ulec zmianie. Obiekty, ktÃ³rych wartoÅ›Ä‡ moÅ¼e ulec zmianie, sÄ… nazywane mutable; obiekty, ktÃ³rych wartoÅ›Ä‡ jest niezmienna po ich utworzeniu, nazywane sÄ… immutable. Typ logiczny bool to dwie staÅ‚e: True i False. a = True print(a) print(type(a)) b = False print(b) print(type(a)) ## True ## &lt;class &#39;bool&#39;&gt; ## False ## &lt;class &#39;bool&#39;&gt; bool jest podtypem liczby caÅ‚kowitej (int). Funkcja isinstance() zostaÅ‚a zaprojektowana specjalnie w celu sprawdzenia, czy dane naleÅ¼Ä… do okreÅ›lonej klasy (typu danych), zaÅ› funkcja issubclass() wskazuje, czy okreÅ›lona klasa jest podklasÄ… okreÅ›lonych klas. print(isinstance(True, int)) print(isinstance(False, int)) print(issubclass(bool, int)) ## True ## True ## True x = True y = 1 z = False print(x + y) print(y + z) ## 2 ## 1 W Pythonie wartoÅ›Ä‡ liczby caÅ‚kowitej nie jest ograniczona liczbÄ… bitÃ³w i moÅ¼e wzrosnÄ…Ä‡ do limitu dostÄ™pnej pamiÄ™ci. W porÃ³wnaniu do np. C++ gdzie int ma wartoÅ›ci od -2147483648 do 2147483647 - 4 bajty. x = 78 y = -5 z = 100 ** 20 print(type(x), x) print(type(y), y) print(type(z), z) ## &lt;class &#39;int&#39;&gt; 78 ## &lt;class &#39;int&#39;&gt; -5 ## &lt;class &#39;int&#39;&gt; 10000000000000000000000000000000000000000 Liczby moÅ¼emy zapisywaÄ‡ takÅ¼e w w Ã³semkowym, szesnastkowym i binarnym systemie liczbowym. x = 0x1 # szesnastkowy y = 0o1 # Ã³semkowy z = 0b1 # binarny print(type(x), x) print(type(y), y) print(type(z), z) ## &lt;class &#39;int&#39;&gt; 1 ## &lt;class &#39;int&#39;&gt; 1 ## &lt;class &#39;int&#39;&gt; 1 Jest takÅ¼e float - typ liczb zmiennoprzecinkowych. x = 0.5 y = -0.5 print(type(x), x) print(type(y), y) ## &lt;class &#39;float&#39;&gt; 0.5 ## &lt;class &#39;float&#39;&gt; -0.5 x = 0.1 + 0.1 y = 0.1 + 0.1 + 0.1 z = 0.3 s = 0.2 print(x == s) print(&quot;{:.20f}&quot;.format(x) ) print(&quot;{:.20f}&quot;.format(s)) print(y == z) print(&quot;{:.20f}&quot;.format(y)) print(&quot;{:.20f}&quot;.format(z)) ## True ## 0.20000000000000001110 ## 0.20000000000000001110 ## False ## 0.30000000000000004441 ## 0.29999999999999998890 W celu przechowywania ciÄ…gu znakÃ³w uÅ¼ywamy typu string. a = &#39;A wewnÄ…trz moÅ¼na umieÅ›ciÄ‡ &quot;cudzysÅ‚Ã³w&quot;&#39; b = &quot;A wewnÄ…trz moÅ¼na umieÅ›ciÄ‡ &#39;apostrof&#39;&quot; Trzy pojedyncze apostrofy sÄ… wygodne do zapisania tekstu w kilku linijkach. c = &#39;&#39;&#39;Trzy pojedyncze apostrofy&#39;&#39;&#39; W celu dokumentacji uÅ¼ywamy trzech cudzysÅ‚owÃ³w. d = &quot;&quot;&quot;Trzy cudzysÅ‚owy&quot;&quot;&quot; Å»eby odwoÅ‚aÄ‡ siÄ™ do poszczegÃ³lnych czÄ™Å›ci sÅ‚owa indeksujemy. a = &#39;Laura jadÅ‚a jabÅ‚ko&#39; print(type(a), a) print(&#39;len(a): &#39;, len(a)) # sprawdzanie dÅ‚ugoÅ›ci sÅ‚owa print(type(a[0]), &#39;a[0]: &#39;, a[0]) # pierwszy element ma indeks 0 print(&#39;a[1]: &#39;, a[1]) print(&#39;a[len(a) - 1]: &#39;, a[len(a) - 1]) # ostatni element to dÅ‚ugoÅ›Ä‡ - 1, poniewaÅ¼ indeksujemy od 0 print(&#39;a[-1] = a[len(a) - 1]: &#39;, a[-1]) # indeksy ujemne liczÄ… od ostatniego znaku print(&#39;a[-18] = a[0]: &#39;, a[-18]) ## &lt;class &#39;str&#39;&gt; Laura jadÅ‚a jabÅ‚ko ## len(a): 20 ## &lt;class &#39;str&#39;&gt; a[0]: L ## a[1]: a ## a[len(a) - 1]: o ## a[-1] = a[len(a) - 1]: o ## a[-18] = a[0]: u a = &#39;Laura jadÅ‚a jabÅ‚ko&#39; b = a print(id(a), a) print(id(b), b) a += &#39;!&#39; print(id(a), a) print(id(b), b) ## 1857431292848 Laura jadÅ‚a jabÅ‚ko ## 1857431292848 Laura jadÅ‚a jabÅ‚ko ## 1857431293744 Laura jadÅ‚a jabÅ‚ko! ## 1857431292848 Laura jadÅ‚a jabÅ‚ko Do zastanowieniaâ€¦ Co znaczy, Å¼e jÄ™zyk jest dynamicznie typowany? Co znaczy, Å¼e jÄ™zyk jest interpretowany? Podaj przykÅ‚ady Jak sprawdziÄ‡, czy wartoÅ›Ä‡ naleÅ¼y do jakiejÅ› klasy? Jak sprawdziÄ‡ dÅ‚ugoÅ›Ä‡ string? Jak napisaÄ‡ wiersz w Pythonie? 2.2.2 Struktury danych W zaleÅ¼noÅ›ci od zadania i problemu nasze dane chcemy przechowywaÄ‡ w przeznaczony do tego sposÃ³b - w tym celu uÅ¼ywamy wÅ‚aÅ›nie tzw. struktur danych. JednÄ… z najprostszych jest lista - zezwala ona na przechowywanie elementÃ³w o rÃ³Å¼nych typach i swobodne odwoÅ‚anie siÄ™ do nich, a takÅ¼e Å‚atwe dodawanie i usuwanie wartoÅ›ci. s = [] # pusta lista print(s) print(type(s)) print(&quot;len:&quot;,len(s)) l = [1, 2, 3, 5, 7] # lista elementÃ³w typu int print(l) print(len(l)) a = [0] * 10 # lista o danym rozmiarze print(a) print(len(a)) ## [] ## &lt;class &#39;list&#39;&gt; ## len: 0 ## [1, 2, 3, 5, 7] ## 5 ## [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ## 10 Lista jest takÅ¼e obiektem iterowalnym - oznacza to, Å¼e jest przystosowana do â€œlecenia element po elemencie.â€ b = list(&#39;lista&#39;) print(b) print(len(b)) mix = [7,&#39;ğŸ‘»&#39;,&#39;rÃ³Å¼a&#39;, 3 + 2j] # w listach moÅ¼e byÄ‡ &quot;wszystko&quot; print(mix) print(len(mix)) print(type(mix[1]), mix[1]) # indeksujemy ## [&#39;l&#39;, &#39;i&#39;, &#39;s&#39;, &#39;t&#39;, &#39;a&#39;] ## 5 ## [7, &#39;ğŸ‘»&#39;, &#39;rÃ³Å¼a&#39;, (3+2j)] ## 4 ## &lt;class &#39;str&#39;&gt; ğŸ‘» Warto przyjrzeÄ‡ sie liÅ›cie takÅ¼e patrzÄ…c na rÃ³Å¼nicÄ™ mutable vs. immutable. m = [1, 2, 3] n = m print(id(m), m) print(id(n), n) m.append(&quot;sÅ‚oÅ„&quot;) print(id(m), m) print(id(n), n) ## 1876034539912 [1, 2, 3] ## 1876034539912 [1, 2, 3] ## 1876034539912 [1, 2, 3, &#39;sÅ‚oÅ„&#39;] ## 1876034539912 [1, 2, 3, &#39;sÅ‚oÅ„&#39;] Przydaje siÄ™ funkcja copy()â€¦ bez zaskoczeÅ„ tworzÄ…ca kopiÄ™ danego obiektu. l = [1, 2, 3, 5, 7] more_lists = l[:] #slices more_list2 = l.copy() print(id(l), l) print(id(more_lists), more_lists) print(id(more_list2), more_list2) ## 3076264382856 [1, 2, 3, 5, 7] ## 3076264383368 [1, 2, 3, 5, 7] ## 3076266393992 [1, 2, 3, 5, 7] Bardzo przydatnÄ… umiejÄ™tnoÅ›ciÄ… jest zaznajomienie z obiektem slice (pl: wykrojenie?). SÅ‚uÅ¼y on do wygodnego tworzenia ciÄ…gÃ³w arytmetycznych, a takÅ¼e indeksowania po utworzonych sekwencjach. SkÅ‚adnia slice() to slice(start, stop, step). l = [1, 2, 3, 5, 7] sl = slice(2, 5, 1) print(type(sl), sl) print(l[sl]) print(l[2:5:1]) print(l) ## &lt;class &#39;slice&#39;&gt; slice(2, 5, 1) ## [3, 5, 7] ## [3, 5, 7] ## [1, 2, 3, 5, 7] AbstrahujÄ…c od wykrojeÅ„, generalnie odwoÅ‚ywanie siÄ™ do rÃ³Å¼nych elementÃ³w listy w zaleÅ¼noÅ›ci od potrzeb niemalÅ¼e zawsze jest bardzo proste i Å‚atwe do napisania - przyjrzyjmy siÄ™ poniÅ¼szym przykÅ‚adom. lis = [1, 2, 3, 5, 7] print(lis[-1]) # ostatni element print(lis[-1:]) # ostatni element, ale ... print(lis[::-1]) # odwrotna kolejnoÅ›Ä‡ print(lis[::2]) # elelemty z indeksami parzystymi print(lis[:-2]) # caÅ‚a sekwencja poza ostatnimi dwoma elementami print(lis[1::2]) # elementy z indeksami nieparzystymi ## 7 ## [7] ## [7, 5, 3, 2, 1] ## [1, 3, 7] ## [1, 2, 3] ## [2, 5] Na pozornie podobnej zasadzie jak slice dziaÅ‚a range. Ten moÅ¼e przyjÄ…Ä‡ jeden, dwa lub trzy parametry: range(stop) range(start, stop) range(start, stop, step) Przyjrzyj siÄ™ kolejnym wywoÅ‚aniom i pomyÅ›l: czym roÅ¼niÄ… siÄ™ slice i range? range_ = range(20) print(type(range_),range_) a = list(range(20)) b = [range(10, 20, 1)] c = list(range(10, 20, 1)) print(&quot;a:&quot;, a) print(&quot;b:&quot;, b) print(&quot;c:&quot;, c) ## &lt;class &#39;range&#39;&gt; range(0, 20) ## a: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] ## b: [range(10, 20)] ## c: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] SprawdÅº siÄ™! StwÃ³rz listÄ™ liczb od 0 do 500 Policz sumÄ™ wszystkich elementÃ³w tej listy OdwrÃ³Ä‡ tÄ™ listÄ™ Dodaj na poczÄ…tek sÅ‚owo PoweR StwÃ³rz listÄ™ parzystych liczb o dÅ‚ugoÅ›ci 50 Dla stringa â€œPoweR warsztaty i przygoda!â€, usuÅ„ wszystkie litery z 6 znaku aÅ¼ do koÅ„ca, wyÅ›wietl otrzymany string (oczekiwana wartoÅ›Ä‡: â€œPoweRâ€) Mamy 2 stringi - s1 i s2. StwÃ³rz nowy string dodajÄ…c s2 w Å›rodku s1. PrzykÅ‚adowo: Przed: â€œSupplementaryâ€ i â€œVectorâ€ Po: â€œSupplVectorementaryâ€ Policz liczbÄ™ wystÄ…pieÅ„ litery e w stringu â€œPoweR is the best event evERâ€ nie patrzÄ…c na wielkoÅ›Ä‡ litery (oczekiwana wartoÅ›Ä‡: 7) â€¦ JednÄ… z naistotniejszych struktur danych w Pythonie sÄ… tuple, zwane takÅ¼e krotkami. a = () # pusta tuple print(type(a), a) a = (1,2,3,4) # deklaracja print(type(a), a) a = 1,2,3,4 # inna deklaracja print(type(a), a) a = (1) # waÅ¼ne sÄ… przecinki, a nie nawiasy print(type(a), a) a = 1, # tuple z 1 elementem print(type(a), a) n_tuple = (&quot;mouse&quot;, [8, 4, 6], (1, 2, 3)) print(type(n_tuple), n_tuple) ## &lt;class &#39;tuple&#39;&gt; () ## &lt;class &#39;tuple&#39;&gt; (1, 2, 3, 4) ## &lt;class &#39;tuple&#39;&gt; (1, 2, 3, 4) ## &lt;class &#39;int&#39;&gt; 1 ## &lt;class &#39;tuple&#39;&gt; (1,) ## &lt;class &#39;tuple&#39;&gt; (&#39;mouse&#39;, [8, 4, 6], (1, 2, 3)) KolejnÄ… waÅ¼nÄ… strukturÄ… sÄ… sÅ‚owniki - ich idea to przechowywania wartoÅ›ci pod odpowiednimi kluczami. NaleÅ¼y pamiÄ™taÄ‡, Å¼e klucz jest tylko obiektem immutable (hashowalnym) i jeden klucz moÅ¼e mieÄ‡ tylko jednÄ… wartoÅ›Ä‡ (jeÅ¼eli bÄ™dzie dodane kilka par z tym samym kluczem, Python zapisze ostatni). Protip: jeÅ›li chcesz zapisaÄ‡ kolejnoÅ›Ä‡, w ktÃ³rej elementy zostaÅ‚y dodane do sÅ‚ownika, uÅ¼yj funkcji collections.OrderedDict(). a = dict() # pusty sÅ‚ownik b = {} # alternatywa na deklaracje pustego sÅ‚ownika c = {&#39;klucz&#39;: &#39;wartoÅ›Ä‡&#39;} print(type(a), a) print(type(b), b) print(type(c), c) a[&#39;new_key&#39;] = &#39;new_value&#39; # Dodajemy nowy element do sÅ‚ownika a[(7, 8)] = [(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;),&#39;ğŸ¤–&#39;] print(a) a[&#39;new_key&#39;] = &#39;ğŸ‘§&#39; print(a) ## &lt;class &#39;dict&#39;&gt; {} ## &lt;class &#39;dict&#39;&gt; {} ## &lt;class &#39;dict&#39;&gt; {&#39;klucz&#39;: &#39;wartoÅ›Ä‡&#39;} ## {&#39;new_key&#39;: &#39;new_value&#39;, (7, 8): [(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), &#39;ğŸ¤–&#39;]} ## {&#39;new_key&#39;: &#39;ğŸ‘§&#39;, (7, 8): [(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), &#39;ğŸ¤–&#39;]} JeÅ›li klucz nie wystÄ™puje w sÅ‚owniku, pojawia siÄ™ error. Å»eby tak nie byÅ‚o trzeba dodatkowo zdefiniowaÄ‡ zachowanie __missing__(key). PoniÅ¼sze operacje nie zadziaÅ‚ajÄ… poprawnie. print(c[&#39;nieklucz&#39;]) a[[1, 2]] = &#39;nie dziaÅ‚a&#39; Do przechowywania wartoÅ›ci unikalnych, przyda nam sie set - zbiÃ³r. NajproÅ›ciej mÃ³wiÄ…c jest to â€kontenerâ€ zawierajÄ…cy niepowtarzalne elementy w losowej kolejnoÅ›ci. Czas sprawdzenia czy jakiÅ› obiekt jest w zbiorze jest staÅ‚y, w porÃ³wnaniu do listy albo krotki, w ktÃ³rych czas jest liniowo zaleÅ¼ny od liczby elementÃ³w. a = set() print(type(a), a) a = {} # nie set , a ... print(type(a), a) a = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;} print(type(a), a) mixed_set = {2.0, &quot;Nicholas&quot;, (1, 2, 3)} print(type(mixed_set), mixed_set) mixed_set.add(&quot;Katty&quot;) print(type(mixed_set), mixed_set) JeÅ¼eli chcielibyÅ›my dodaÄ‡ do zbioru element juÅ¼ w nim bÄ™dÄ…cy - set go zignoruje. a = {[1,2,3], [1,2,3]} 2.2.3 Operatory W celu wykonania operacji arytmetycznych i dokonania innych ingerencji miÄ™dzy obiektami, skÅ‚adnia jest prosta i nieodbiegajÄ…ca od standardu innych jÄ™zykÃ³w programowania. Arytmetyczne: dodawanie odejmowanie mnoÅ¼enie ** potÄ™gowanie / dzielenie -&gt; float // dzielenie z zaokrÄ…gleniem do najbliÅ¼szego int w dÃ³Å‚ % reszta z dzielenia PorÃ³wnania: == rÃ³wne co do wartoÅ›ci != rÃ³Å¼ne co do wartoÅ›ci is zwraca true, jeÅ›li obie zmienne sÄ… tym samym obiektem (porÃ³wnuje wyniki funkcji id, adresy obiektÃ³w przechowywane w pamiÄ™ci) is not zwraca true, jeÅ›li obie zmienne nie sÄ… tym samym obiektem &lt; mniejsze wiÄ™ksze = wiÄ™ksze lub rÃ³wne &lt;= mniejsze lub rÃ³wne in zwraca wartoÅ›Ä‡ True, jeÅ›li w obiekcie znajduje siÄ™ sekwencja o okreÅ›lonej wartoÅ›ci (np litera w stringu) not in czy obiekt nie jest zawarty w innym obiekcie Logiczne: and zwraca wartoÅ›Ä‡ True, jeÅ›li obie instrukcje sÄ… prawdziwe x &lt; 5 and x &lt; 10 or zwraca wartoÅ›Ä‡ True, jeÅ›li jedno z wyraÅ¼eÅ„ jest prawdziwe x &lt; 5 or x &lt; 4 not odwraca wynik, zwraca False, jeÅ›li wynik jest prawdziwy(x &lt; 5 and x &lt; 10) TrochÄ™ o operatorze in: 1. W listach sÄ… przeszukiwane wszystkie elementy po kolei. Czas wyszukiwania zaleÅ¼y od rozmiaru listy. 2. Dla zbiorÃ³w wyszukiwanie nie zaleÅ¼y od rozmiaru zbioru - jest staÅ‚e 3. W przypadku sÅ‚ownikÃ³w wyszukiwane sÄ… tylko klucze, czas wyszukiwania nie zaleÅ¼y od liczby elementÃ³w w sÅ‚owniku. Åšrednio O(1) Uwaga! Do porÃ³wnywania stosujemy tylko ==. Jest to bardzo waÅ¼ne, gdyÅ¼ niedbaÅ‚e mylenie == z = to typowy bÅ‚Ä…d poczÄ…tkujÄ…cych programistÃ³w, ktÃ³ry niezwykle czÄ™sto doprowadza do porozumieÅ„ i zepsucia kodu tylko przez tÄ… jednÄ… literkÄ™, ktÃ³rÄ… niekiedy i wychwyciÄ‡ nieÅ‚atwo. Zobaczmy nasze oparatory w akcji. x = 256 y = 256 print(&#39;id(x)&#39;, id(x)) print(&#39;id(y)&#39;, id(y)) print(&#39;x is y&#39;, x is x) print(&#39;x == y&#39;, x == y) x = 257 y = 257 print(&#39;id(x)&#39;, id(x)) print(&#39;id(y)&#39;, id(y)) print(&#39;x is y&#39;, x is y) print(&#39;x == y&#39;, x == y) ## id(x) 140704384598384 ## id(y) 140704384598384 ## x is y True ## x == y True ## id(x) 2065240868912 ## id(y) 2065240868912 ## x is y True ## x == y True ZwrÃ³Ä‡ uwagÄ™, jak zmieniÅ‚o siÄ™ zachowanie Pythona dla operatorÃ³w == i is - dzieje siÄ™ tak dlatego, Å¼e zwzglÄ™dÃ³w optymalizacyjnych liczby â€œmaÅ‚eâ€ sÄ… nieco inaczej interpretowane. 2.2.4 Instrukcja warunkowa â€¦ to element jÄ™zyka pozwalajÄ…cy na wybÃ³r rÃ³Å¼nych Å›cieÅ¼ek operacji w zaleÅ¼noÅ›ci od speÅ‚nionych warunkÃ³w. Kluczowa jest umiejÄ™tnoÅ›Ä‡ uÅ¼ytku i rozumienia instrukcji if, else i elif (skrÃ³t od else if). DziaÅ‚ajÄ… one niemalÅ¼e tak, jak moÅ¼na by siÄ™ spodziewaÄ‡ po ich tÅ‚umaczeniach. x = 10 print(&#39;przed ifem&#39;) if x == 10: print(&#39;x=10&#39;) elif x == 4: print(&#39;x=4&#39;) elif x == 5: print(&#39;x=5&#39;) else: print(&#39;else&#39;) print(&#39;po ifie&#39;) ## przed ifem ## x=10 ## po ifie 2.2.5 PÄ™tle W celu wykonania danego bloku operacji wiele razy korzystamy z pÄ™tli. Tak jak i w przypadku innych popularnych jÄ™zykÃ³w programowania, kluczowa jest znajomoÅ›Ä‡ for i while. Na tÄ… pierwszÄ… najwygodniej patrzeÄ‡ jak na pÄ™tlÄ™ â€œdla kaÅ¼degoâ€¦â€. Oto jej dziaÅ‚anie: for number in range(5): print(number) ## 0 ## 1 ## 2 ## 3 ## 4 IterowaÄ‡ moÅ¼emy po po dowolnych iterowalnych obiektach. mix = [7,&#39;ğŸ‘»&#39;,&#39;rÃ³Å¼a&#39;, 3 + 2j] for el in mix: print(el) print(&quot;==========================================================================&quot;) for i in &#39;hello world&#39;: print(i * 2, end = &#39;&#39;) ## 7 ## ğŸ‘» ## rÃ³Å¼a ## (3+2j) ## ========================================================================== ## hheelllloo wwoorrlldd W celu przerwania dziaÅ‚ania pÄ™tli korzystamy z instrukcji break, zaÅ› kiedy chcemy rozpoczÄ…Ä‡ nastÄ™pny obrÃ³t pÄ™tli, omijajÄ…c pozostaÅ‚Ä… czÄ™Å›Ä‡ - uÅ¼ywamy continue. for i in &#39;hello world&#39;: if i == &#39;e&#39;: break print(i * 2, end = &#39;&#39;) ## hh for i in &#39;hello world&#39;: if i == &#39;o&#39;: continue print(i * 2, end = &#39;&#39;) ## hheellll wwrrlldd Przydatna jest teÅ¼ operacja else dla pÄ™tli - wykona siÄ™ ona, jeÅ›li pÄ™tla zakoÅ„czyÅ‚a siÄ™ normalnie (nie za pomocÄ… break). for i in &#39;hello world&#39;: if i == &#39;a&#39;: break else: print(&#39;Nie ma takiej litery&#39;) ## Nie ma takiej litery DrugÄ… pÄ™tlÄ… jakiej moÅ¼emy uÅ¼yÄ‡ w Pythonie jest while - zezwala ona na wykonywanie operacji w bloku kodu jej przeznaczonym tak dÅ‚ugo, aÅ¼ wpisany przez programistÄ™ warunek bÄ™dzie speÅ‚niony. Intuicja: while to taki if wykonywany wielokrotnie [o ile warunek jest speÅ‚niany]. i = 5 while i &lt; 15: print(i) i = i + 2 ## 5 ## 7 ## 9 ## 11 ## 13 Rezultaty pÄ™tli for moÅ¼emy takÅ¼e zapisywaÄ‡ w taki oto skrÃ³towy sposÃ³b: squares = [] for x in range(10): squares.append(x ** 2) print(squares) squares = [x**2 for x in range(10)] print (squares) b = [x for x in range(10) if not x%3] # lista liczb podzielnych przez 3 and &lt; 10 print(b) ## [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] ## [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] ## [0, 3, 6, 9] MoÅ¼na takÅ¼e skÅ‚adaÄ‡ zbiory i sÅ‚owniki. a = {str(i):i for i in [1,2,3,4,5]} # sÅ‚ownik print(a) a = {x for x in range(10) } # set print(a) ## {&#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5} ## {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} Oraz tuple. Tylko uwaÅ¼aj! a = (x for x in range(10)) # generatory print(type(a)) print(next(a)) print(next(a)) b = tuple(x for x in range(10)) # tuple print(type(b)) ## &lt;class &#39;generator&#39;&gt; ## 0 ## 1 ## &lt;class &#39;tuple&#39;&gt; SprawdÅº siÄ™! Mamy 2 listy. Wypisz True jeÅ›li pierwszy i ostatni element na liÅ›cie jest taki sam ZrÃ³b listÄ™ od 1 do 100 i wypisz wszystkie liczby podzielne przez 5 Wypisz takÄ… piramidÄ™ 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 (PamiÄ™taj o print (â€¦, end=&quot; &quot;)) PoÅ‚Ä…cz dwie listy tak, Å¼e do wynikowej listy z pierwszej bÄ™dÄ… liczby nie parzyste, a z drugiej parzyste. PrzykÅ‚adowo: list1 = [15, 22, 23, 17, 19] list2 = [24, 43, 24, 36, 11] Merged List is [15, 23, 17, 19, 24, 24, 36] Policz wystÄ…pienia kolejnych elementÃ³w i na podstawie tego stwÃ³rz sÅ‚ownik. PrzykÅ‚adowo: list1 = [121, 43, 87, 121, 23, 43, 43, 43, 87] dict1 = {121: 2, 43: 4, 87: 2, 23: 1} Rozpakuj krotkÄ™ do wartoÅ›ci ZamieÅ„ wszystkie ostatnie wartoÅ›ci w tuple na 99. PrzykÅ‚adowo: l1 = [(10, 20, 40), (40, 50, 60), (70, 80, 90)] result = [(10, 20, 99), (40, 50, 99), (70, 80, 99)] Mamy listÄ™ mix[string, int , float â€¦]. StwÃ³rz nowÄ… listÄ™ ktÃ³ra bÄ™dzie miaÅ‚a tylko int. 2.2.6 Funkcje W Pythonie definiuje siÄ™ je za pomocÄ… sÅ‚owa kluczowego def: def func(): print(&quot;Hi, dear!&quot;) func() ## Hi, dear! W zaleÅ¼noÅ›ci od deklaracji, funkcja moÅ¼e przyjÄ…Ä‡ dowolnÄ… liczbÄ™ argumentÃ³w o niemalÅ¼e ograniczonej swobodzie wyboru typÃ³w. def greet(name): &quot;&quot;&quot;This function greets to the person passed in as parameter&quot;&quot;&quot; print(&quot;Hello, &quot; + name + &quot;. Good morning!&quot;) print(greet.__doc__) greet(&quot;Kate&quot;) ## This function greets to the person passed in as parameter ## Hello, Kate. Good morning! W przypadku podawania argumentÃ³w pozycyjnie, podaje siÄ™ je po nazwie funkcji w nawiasach. MoÅ¼esz dodaÄ‡ dowolnÄ… liczbÄ™ argumentÃ³w - po prostu oddziel je przecinkiem. def func(name): return name + &quot; Ref&quot; a = func(&quot;Katty&quot;) print(a) print(func(&quot;Lila&quot;)) print(func(&quot;Ewa&quot;)) ## Katty Ref ## Lila Ref ## Ewa Ref MoÅ¼na teÅ¼ podawaÄ‡ argumenty kluczowo, tj. przez nazwanie. Wtedy kolejnoÅ›Ä‡ jest niewaÅ¼na. def func(person3, person2, person1): print(&quot;Imie ryczerza to &quot; + person3) func(person1 = &quot;Emil&quot;, person2 = &quot;Tobias&quot;, person3 = &quot;Linus&quot;) ## Imie ryczerza to Linus def func(x = 1, y = 1): outcome = x + y print(outcome) func(x = 100) ## 101 Uwaga z kolejnoÅ›ciÄ… argumentÃ³w z wartoÅ›ciami default! Deklaracja poniÅ¼szej funkcji nie bÄ™dzie poprawna. def greet(msg = &quot;Good morning!&quot;, name): pass MoÅ¼na za to napisaÄ‡ w taki sposÃ³b: def gree(name, msg = &quot;Good morming!&quot;): pass Python daje takÅ¼e moÅ¼liwoÅ›Ä‡ uÅ¼ycia Args - arbitrary arguments. JeÅ›li nie wiesz, ile argumentÃ³w zostanie przekazanych do funkcji, dodaj gwiazdkÄ™ przed nazwÄ… parametru w definicji funkcji. def func(*args): print(type(args)) print(&quot;Imie ryczerza to &quot; + args[2]) func(&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;) ## &lt;class &#39;tuple&#39;&gt; ## Imie ryczerza to Linus SÄ… takÅ¼e i Kwargs - arbitrary keyword arguments. JeÅ›li nie wiesz, ile argumentÃ³w nazwanych zostanie przekazanych do funkcji, dodaj dwie gwiazdki przed nazwÄ… parametru w definicji funkcji. def func_kwargs(**places): print(&quot;Jestem z &quot; + places[&quot;region&quot;] + &quot; wojewÃ³dztwa&quot;) func_kwargs(city = &quot;Warszawa&quot;, region = &quot;ÅÃ³dzkiego&quot;) PamiÄ™tajmy o Mutable vs. Immutable! PoniÅ¼ej niepoprawnie zadeklarowana funkcja i tego efekty: def printing(lista = []): lista.append(&#39;print&#39;) for el in lista: print(id(lista), el) printing() li = [&#39;nowe sÅ‚owo&#39;] print(id(li)) printing(li) printing() ## 2168984129928 print ## 2169014454920 ## 2169014454920 nowe sÅ‚owo ## 2169014454920 print ## 2168984129928 print ## 2168984129928 print NiÅ¼ej juÅ¼ poprawna implementacja i jej wywoÅ‚anie: def printing(lista = None): print(&quot;Przed if: &quot;,id(lista)) lista = lista if lista else [] # druga opcja lista or [] print(&quot;Po if: &quot;, id(lista)) lista.append(&#39;print&#39;) for el in lista: print(id(lista), el) printing() printing() l = [&#39;nowe sÅ‚owo&#39;] print(&quot;Przed wywoÅ‚aniem funkcji: &quot;, id(l)) printing(l) ## Przed if: 140704384113888 ## Po if: 2398374744968 ## 2398374744968 print ## Przed if: 140704384113888 ## Po if: 2398374744968 ## 2398374744968 print ## Przed wywoÅ‚aniem funkcji: 2398374744968 ## Przed if: 2398374744968 ## Po if: 2398374744968 ## 2398374744968 nowe sÅ‚owo ## 2398374744968 print SprawdÅº siÄ™! Napisz program, ktÃ³ry znajdzie wszystkie takie liczby, ktÃ³re sÄ… podzielne przez 7, ale nie sÄ… wielokrotnoÅ›ciÄ… 5, od 2000 do 3200 (wÅ‚Ä…cznie). Otrzymane liczby naleÅ¼y wydrukowaÄ‡ w oddzielonej przecinkami sekwencji w jednym wierszu. Napisz funkcjÄ™, ktÃ³ra oblicza i drukuje wartoÅ›Ä‡ zgodnie z podanÄ… formuÅ‚Ä…: Q = (2 * C * D) / H, gdzie: C - argument nienazwany - integer D - argument nienazwany - integer H - nie wiadomo ile jest argumentÃ³w nienazwanych (jeÅ¼eli wiÄ™cej niÅ¼ 1 to zsumowaÄ‡ H1 + H2 + H3) ZrÃ³b funkcjÄ™, przyjmujÄ…cÄ… listÄ™ tuple, indeks(â€œiâ€) i wartoÅ›Ä‡(â€œwâ€). ZamieÅ„ wszystkie wartoÅ›ci na indeksie â€œiâ€ w tuple na wartoÅ›Ä‡ (â€œwâ€). PrzykÅ‚adowo: l1 = [(10, 20, 40), (40, 50, 60), (70, 80, 90)] change(l1,1,77) result = [(10, 77, 40), (40, 77, 60), (70, 77, 90)] 2.2.7 Ramka danych i pandas - maÅ‚y wstÄ™p W kolejnych krokach bÄ™dziemy braÄ‡ pod lupÄ™ dwa rodzaje tabel: Series - jest to jednowymiarowa struktura danych (â€jednowymiarowa tablicaâ€), ktÃ³ra moÅ¼e przechowywaÄ‡ wartoÅ›ci i dla kaÅ¼dej wartoÅ›ci ma takÅ¼e unikalny indeks DataFrame - dwuwymiarowa (lub wiÄ™cej) wymiarowa struktura danych - w zasadzie tabela z wierszami i kolumnami. Kolumny majÄ… nazwy, a wiersze indeksy. Pandas to doskonaÅ‚a biblioteka implementujÄ…ca wiele przydatnych narzedzi do obrÃ³bki i pracÄ… nad ramkÄ… danych. Aby mÃ³c korzystaÄ‡ z jej mocy, musimy wczytaÄ‡ (i ewentualnie zainstalowaÄ‡, jeÅ¼eli nie zostaÅ‚o to wczeÅ›niej zrobione) pakiet. Standardowo przyjÄ™Å‚o siÄ™ wczytywaÄ‡ go jako pd - dodanie do instrukcji wczytywania biblioteki magicznych czterech liter as pd zezwoli nam na moÅ¼liwoÅ›Ä‡ odwoÅ‚ywania sie w kaÅ¼dym kolejnym kroku kiedy bÄ™dziemy potrzebowaÄ‡ pandas nie do caÅ‚ej szeÅ›cioliterowej nazwy pakietu, ale tylko do tych dwÃ³ch prostych znakÃ³w. JeÅ¼eli nie masz jeszcze zainstalowanego pakietu pandas - uÅ¼yj instrukcji jak niÅ¼ej. install.packages(&quot;pandas&quot;) import pandas as pd DziÄ™ki pandas moÅ¼emy Å‚atwo wczytywaÄ‡ gotowe pliki .csv. Instrukcja read_csv standardowo przyjmuje dwa argumenty - Å›cieÅ¼kÄ™ do pliku i opcjonalnie delimiter - sposÃ³b, w jaki oddzielone sÄ… kolejne wartoÅ›ci w wierszach. data = pd.read_csv(&quot;files/movies.csv&quot;, delimiter = &#39;,&#39;) Tak utworzona ramka danych ma swÃ³j wÅ‚asny typ. print(type(data.head())) MoÅ¼emy Å‚atwo odwoÅ‚aÄ‡ siÄ™ do pierwszych lub ostatnich wierszy data frame za pomocÄ… metod head() i tail(). display(data.tail()) display(data.head()) Do zwrÃ³cenia losowych rows uÅ¼ywamy sample(). data.sample(5) MoÅ¼emy takÅ¼e Å‚atwo odwoÅ‚aÄ‡ siÄ™ do wierszy speÅ‚niajÄ…cych podane kryteria. PrzykÅ‚adowo poniÅ¼sza instrukcja zwrÃ³ci nam te, dla ktÃ³rych wartoÅ›Ä‡ odpowiadajÄ…ca za title przyjmuje &quot;Apaches*. data[data.title == &quot;Apaches&quot;] SprawdÅº siÄ™! SprawdÅº szczegÃ³Å‚owe informacje o DataFrame Uzyskaj pierwsze 3 wiersze danych WyÅ›wietl kolumny title i description WyÅ›wietl kolumny show_id, country, data_added dla wierszy 0, 3, 6, 24 WyÅ›wietl wiersze gdzie release_year &gt; 2010 WyÅ›wietl wiersze, gdzie director is NaN Policz ile jest takich wierszy jak w punkcie 5. SprawdÅº typ kolumny duration SprawdÅº co to znaczy ZmieÅ„ nazwÄ™ kolumny title na name Dodaj nowy wiersz "]
]
