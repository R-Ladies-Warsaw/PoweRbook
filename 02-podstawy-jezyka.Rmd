# Podstawy jÄ™zyka {#podstawy-jezyka}

WstÄ™p do Pythona i R

## R

<img align="center" src="figure/cheatSheetR1.png" alt="drawing"/>

### Podstawowe operacje

NastÄ™pujÄ…cy kod bÄ™dzie pisany w oprogramowaniu **RStudio**. Jest to najbardziej powszechne Å›rodowisko programistyczne *R*-a, integrujÄ…ce takÅ¼e wiele innych przydatnych funkcjonalnoÅ›ci.

R to bardzo wygodne narzÄ™dzie w kwestii operacji arytmetycznych. SprawdÅºmy jak sprawdzi siÄ™ dla paru z nich!
```{r}
2 + 2
2 + 2 + 2 + 2
2^4
```

OprÃ³cz wyÅ¼ej wymienionych moÅ¼na takÅ¼e dokonywaÄ‡ wielu innych obliczeÅ„. Zachowywana jest takÅ¼e kolejnoÅ›Ä‡ dziaÅ‚aÅ„.

**Zadanie 1**

SprawdÅº czy R zachowuje kolejnoÅ›Ä‡ dzialaÅ„. Jakiego przykladu moÅ¼na uzyÄ‡?

*PrzykÅ‚adowe rozwiÄ…zanie:*
```{r}
2 + 2 * 2
```

W R-rze istniejÄ… dwie metody przypisania. GÅ‚ownie uÅ¼ywamy skÅ‚adni *x <- 5* (moÅ¼liwe takÅ¼e *5 -> x*), ale istnieje rownieÅ¼ opcja moÅ¼e bardziej instynktownego *x = 5*. Standardowo przynajmniej na tym etapie lepiej jest jednak uÅ¼ywaÄ‡ "strzaÅ‚ki".
```{r}
x <- 5
x
y = 5
zmienna <- "Hello World!"
```

### Struktury danych

JednÄ… z podstawowych sÄ… *wektory*. SÅ‚uÅ¼Ä… one do przechowywania pewnej liczby elementÃ³w w jednej zmiennej.
```{r}
parzyste <- c(2, 4, 6)
litery <- c("a", "b", "c")
litery[2]
vec <- c(parzyste, litery)
vec
```

OczywiÅ›cie i na nich moÅ¼emy dokonywaÄ‡ rÃ³Å¼nych operacji.
```{r}
nieparzyste <- c(1, 3, 5)
parzyste + nieparzyste
parzyste * x
```

InnÄ… istotnÄ… strukturÄ… sÄ… *listy*.
```{r}
liczby <- list(parzyste = parzyste, nieparzyste = nieparzyste)
c(parzyste, nieparzyste)
liczby[[1]]
liczby[["parzyste"]]
```

**Zadanie 2**

a) StwÃ³rz dwa wektory skÅ‚adajÄ…ce siÄ™ z 5 liczb kaÅ¼dy, a nastÄ™pnie przypisz ich roÅ¼nice do nowej zmiennej o nazwie rÃ³Å¼nica.

b) PoÅ‚Ä…cz te trzy wektory w listÄ™.

*PrzykÅ‚adowe rozwiÄ…zanie:*

a)
```{r}
a <- c(1, 2, 3, 4, 5)
b <- c(6, 7, 8, 9, 10)
roznica <- b - a
```
b)
```{r}
lista_wektorow <- list(a, b, roznica)
```

R jest takÅ¼e bogaty w szereg przydatnych funkcji wbudowanych. Oto niektÃ³re z nich i ich dziaÅ‚anie:
```{r, eval = FALSE}
?min # zwraca informacje o funkcji
```
```{r, message = FALSE}
min(roznica)
max(roznica)
sum(roznica)
length(roznica)
vec2 <- 1:20
vec2
vec3 <- 50:100
vec3
```

KolejnÄ… bardzo waÅ¼nÄ… strukturÄ… w R jest *ramka danych*.
```{r}
df <- data.frame(col_1 = c(1, 2, 3), col_2 = c("raz", "dwa", "trzy"))
```

MoÅ¼emy na niej dziaÅ‚aÄ‡ poprzez odpowiednie operatory:
```{r}
df$col_1
df[["col_1"]]
df[3, 1]
df[,1]
df[1,]
df[2:3,]
```

### Instrukcja warunkowa

... to konstrukcja, ktÃ³rej uÅ¼ywamy W celu dokonywania decyzji o wykonywanych krokach. NajproÅ›ciej mÃ³wiÄ…c owy element jÄ™zyka pozwala na wykonanie ciÄ…gu operacji w zaleÅ¼noÅ›ci od zaproponowanego przez programistÄ™ warunku. Oto i przykÅ‚adowe takie warunki:
```{r}
1 == 1
1 == 0
1 > 0
1 < 0
!(1==1)
parzyste
parzyste == 2
all(parzyste == 2)
any(parzyste == 2)
2 %in% parzyste
```

... i sama instrukcja *if* w praktyce:
```{r}
if( !(8 %in% parzyste) ){
  parzyste <- c(parzyste, 8)
}
parzyste

skorupa <- TRUE
if(skorupa == TRUE){
  "zolw"
} else {
  "kot"
}

ifelse(skorupa == TRUE, "zolw", "kot")
```

ifelse dziaÅ‚a teÅ¼ na wektorze:
```{r}
skorupa <- c(TRUE, TRUE, FALSE)
ifelse(skorupa == TRUE, "zolw", "kot")
```

**Zadanie 3**

a) Podobnie jak w powyÅ¼szym przykÅ‚adzie, wektor liczb nieparzystych powiÄ™ksz o liczbe 7, o ile juÅ¼ jej nie ma.
b) Dany jest wektor liczb, v <- c(1,2,2,2,2,2,3,3,3,1,1,2). UÅ¼yj instrukcji if else lub ifelse, zeby zrobiÄ‡ z niego wektor zawierajÄ…cy wartosci "jeden", "dwa", "trzy".

*PrzykÅ‚adowe rozwiÄ…zanie:*

a)
```{r}
if( !(7 %in% nieparzyste) ){
  nieparzyste <- c(nieparzyste, 7)
}
nieparzyste
```

b)
```{r}
v <- 2
ifelse(v == 1, "jeden", ifelse(v == 2, "dwa", "trzy"))
```

### PÄ™tle

CzÄ™sto spotykamy siÄ™ z sytuacjÄ…, kiedy danÄ… operacjÄ™ lub ciÄ…g wielu instrukcji chcemy wykonaÄ‡ wielokrotnie. Do tego wÅ‚aÅ›nie uÅ¼ywamy tytuÅ‚owych konstrukcji.

Dwie najbardziej powszechne to *while* i *for*. Pierwsza z nich dziaÅ‚a na podobnej zasadzie jak intrukcja if - z tym wyjÄ…tkiem, Å¼e warunek sprawdzany jest wielokrotnie - tak dÅ‚ugo, aÅ¼ bÄ™dzie speÅ‚niany.

```{r}
while (length(parzyste) < 10) {
  len <- length(parzyste)
  parzyste <- c(parzyste, parzyste[len] + 2)
}
```

Z drugiej strony for udostÄ™pnia nam moÅ¼liwoÅ›Ä‡ wykonania operacji konkretnÄ… iloÅ›Ä‡ razy - np. dokonujÄ…c czynnoÅ›ci dla kaÅ¼dej liczby z listy.

```{r}
nieparzyste2 <- c()
for(liczba in parzyste){
  nieparzyste2 <- c(nieparzyste2, liczba - 1)
}
```

**Zadanie 4**

a) UÅ¼yj pÄ™tli (ktÃ³rej?), Å¼eby iterujÄ…c po wektorze `liczby <- 1:10` stworzyÄ‡ wektor 10 kolejnych liczb nieparzystych.

b) Czy jest wiÄ™cej niÅ¼ jeden sposob?

*PrzykÅ‚adowe rozwiÄ…zanie:*
a)
```{r}
nieparzyste3 <- c()
for(x in 1:10){
  nieparzyste3 <- c(nieparzyste3, 2 * x - 1)  
}
```

b) AleÅ¼ oczywiÅ›cie, Å¼e tak!

### Pliki i odczyt danych

Bardzo istotnymi funkcjami sÄ… *getwd()* i *setwd()* - pierwsza zwraca Å›cieÅ¼kÄ™ do roboczego katalogu roboczego, zaÅ› druga umoÅ¼liwia ustawienie nowej.

```{r, eval = FALSE}
getwd()
setwd("/Users/ja/mojeskrypty")
```

Do odczytania ramki danych moÅ¼emy uÅ¼yÄ‡ funkcji *read.csv* - w tym celu jako pierwszy argument podajemy Å›cieÅ¼kÄ™ do naszego pliku, a jako opcjonalny drugi - separator [znak lub ciÄ…g oddzielajÄ…cy kolejne kolumki data frame].

```{r, eval = FALSE}
# seriale <- read.csv("<tu nalezy wkleic sciezke do pliku>", sep=";")
seriale <- read.csv("files/netflix_titles.csv")
```

Zobaczmy efekt wywoÅ‚ania naszej funkcji - operacja *head* zwrÃ³ci nam kilka pierwszych wierszy, zaÅ› *View* udostÄ™pnia estetyczny oglÄ…d tabelki.

```{r, eval = FALSE}
head(seriale)
View(seriale)
```

**Zadanie 5**

a) Wypisz nazwy seriali, ktÃ³re wyszÅ‚y w 2020 roku.

b) Wybierz podzbiÃ³r zawierajÄ…cy Twoje 3 ulubione seriale i przypisz go do nowej zmiennej.

*PrzykÅ‚adowe rozwiÄ…zanie:*
a) Tworzymy wektor, ktÃ³ry odpowiada kolejnym wierszom z ramki danych, jeÅ›li zawiera TRUE, to znaczy, Å¼e serial byÅ‚ wydany w 2020, jeÅ›li FALSE oznacza, Å¼e serial byl wydany w innym roku
```{r, eval = FALSE}
ktore_w_2020 <- seriale[["release_year"]] == 2020
```

MoÅ¼emy uÅ¼yc wektora TRUE/FALSE do indeksowania wierszy. PoniÅ¼sze polecenie wybierze tylko te wiersze, w ktÃ³rych wektor *ktore_w_2020* przyjÄ…Å‚ wartoÅ›Ä‡ TRUE.
```{r, eval = FALSE}
seriale_2020 <- seriale[ktore_w_2020, ]
```

b)
```{r, eval = FALSE}
moje_seriale <- seriale[c(1, 2, 10), ]
```

## Python

<img align="center" src="figure/cheatSheetPython1.png" alt="drawing"/>

### Podstawy i proste typy

```{python, python.reticulate = FALSE}
print("Hi!")
```

Python jest jÄ™zykiem **interpretowanym** - najproÅ›ciej mÃ³wiÄ…c oznacza to, Å¼e jest on tÅ‚umaczony i wykonywany "w locie". TÅ‚umaczeniem i wykonywaniem programu zajmuje siÄ™ specjalny program nazwany interpreterem jÄ™zyka.

Najprostszym typem jest **int** - obejmuje on liczby caÅ‚kowite.

```{python, python.reticulate = FALSE}
x = 21
print(x)
print(type(x))
y = 0.3
print(y)
print(type(y))
```
```{python, python.reticulate = FALSE}
def fun(x, y):
    return x + y

x = "Data"
y = "Science"
print(fun(x, y))

x = 5
y = 7
print(fun(x, y))
```

Python jest *dynamicznie typowany* i typowanie jest silne - oznacza to, Å¼e jÄ™zyk nie moÅ¼e niejawnie konwertowaÄ‡ wartoÅ›ci rÃ³Å¼nych typÃ³w.

```{python, python.reticulate = FALSE, eval = FALSE}
a = 2
b = 'L'
c = a + b # zwrÃ³ci bÅ‚Ä…d
```

WartoÅ›ci niektÃ³rych obiektÃ³w mogÄ… ulec zmianie. Obiekty, ktÃ³rych wartoÅ›Ä‡ moÅ¼e ulec zmianie, sÄ… nazywane *mutable*; obiekty, ktÃ³rych wartoÅ›Ä‡ jest niezmienna po ich utworzeniu, nazywane sÄ… *immutable*.

Typ logiczny **bool** to dwie staÅ‚e: True i False.
```{python, python.reticulate = FALSE}
a = True
print(a)
print(type(a))
b = False
print(b)
print(type(a))
```

*bool* jest podtypem liczby caÅ‚kowitej (*int*).

Funkcja *isinstance()* zostaÅ‚a zaprojektowana specjalnie w celu sprawdzenia, czy dane naleÅ¼Ä… do okreÅ›lonej klasy (typu danych), zaÅ› funkcja *issubclass()* wskazuje, czy okreÅ›lona klasa jest podklasÄ… okreÅ›lonych klas.
```{python, python.reticulate = FALSE}
print(isinstance(True, int))
print(isinstance(False, int))
print(issubclass(bool, int))
```
```{python, python.reticulate = FALSE}
x = True
y = 1
z = False
print(x + y)
print(y + z)
```

W Pythonie wartoÅ›Ä‡ liczby caÅ‚kowitej nie jest ograniczona liczbÄ… bitÃ³w i moÅ¼e wzrosnÄ…Ä‡ do limitu dostÄ™pnej pamiÄ™ci.

W porÃ³wnaniu do np. *C++* gdzie *int* ma wartoÅ›ci od -2147483648 do 2147483647 - 4 bajty.
```{python, python.reticulate = FALSE}
x = 78
y = -5
z = 100 ** 20
print(type(x), x)
print(type(y), y)
print(type(z), z)
```

Liczby moÅ¼emy zapisywaÄ‡ takÅ¼e w w Ã³semkowym, szesnastkowym i binarnym systemie liczbowym.
```{python, python.reticulate = FALSE}
x = 0x1  # szesnastkowy
y = 0o1  # Ã³semkowy
z = 0b1  # binarny
print(type(x), x)
print(type(y), y)
print(type(z), z)
```

Jest takÅ¼e **float** - typ liczb zmiennoprzecinkowych.
```{python, python.reticulate = FALSE}
x = 0.5
y = -0.5
print(type(x), x)
print(type(y), y)
```
```{python, python.reticulate = FALSE}
x = 0.1 + 0.1
y = 0.1 + 0.1 + 0.1
z = 0.3
s = 0.2
print(x == s)
print("{:.20f}".format(x) )
print("{:.20f}".format(s))
print(y == z)
print("{:.20f}".format(y))
print("{:.20f}".format(z))
```

W celu przechowywania ciÄ…gu znakÃ³w uÅ¼ywamy typu **string**.
```{python, python.reticulate = FALSE, eval = FALSE}
a = 'A wewnÄ…trz moÅ¼na umieÅ›ciÄ‡ "cudzysÅ‚Ã³w"'
b = "A wewnÄ…trz moÅ¼na umieÅ›ciÄ‡ 'apostrof'"
```

Trzy pojedyncze apostrofy sÄ… wygodne do zapisania tekstu w kilku linijkach.
```{python, python.reticulate = FALSE, eval = FALSE}
c = '''Trzy pojedyncze 
apostrofy'''
```

W celu dokumentacji uÅ¼ywamy trzech cudzysÅ‚owÃ³w.
```{python, python.reticulate = FALSE, eval = FALSE}
d = """Trzy cudzysÅ‚owy"""
```

Å»eby odwoÅ‚aÄ‡ siÄ™ do poszczegÃ³lnych czÄ™Å›ci sÅ‚owa *indeksujemy*.
```{python, python.reticulate = FALSE}
a = 'Laura jadÅ‚a jabÅ‚ko'
print(type(a), a)
print('len(a): ', len(a)) # sprawdzanie dÅ‚ugoÅ›ci sÅ‚owa
print(type(a[0]), 'a[0]: ', a[0]) # pierwszy element ma indeks 0
print('a[1]: ', a[1])
print('a[len(a) - 1]: ', a[len(a) - 1]) # ostatni element to dÅ‚ugoÅ›Ä‡ - 1, poniewaÅ¼ indeksujemy od 0
print('a[-1] = a[len(a) - 1]: ', a[-1]) # indeksy ujemne liczÄ… od ostatniego znaku
print('a[-18] = a[0]: ', a[-18])
```

```{python, python.reticulate = FALSE}
a = 'Laura jadÅ‚a jabÅ‚ko'
b = a
print(id(a), a)
print(id(b), b)
a += '!'
print(id(a), a)
print(id(b), b)
```

*Do zastanowienia...*

1. Co znaczy, Å¼e jÄ™zyk jest dynamicznie typowany?
2. Co znaczy, Å¼e jÄ™zyk jest interpretowany? Podaj przykÅ‚ady
3. Jak sprawdziÄ‡, czy wartoÅ›Ä‡ naleÅ¼y do jakiejÅ› klasy?
4. Jak sprawdziÄ‡ dÅ‚ugoÅ›Ä‡ string?
5. Jak napisaÄ‡ wiersz w Pythonie?

### Struktury danych

W zaleÅ¼noÅ›ci od zadania i problemu nasze dane chcemy przechowywaÄ‡ w przeznaczony do tego sposÃ³b - w tym celu uÅ¼ywamy wÅ‚aÅ›nie tzw. struktur danych. JednÄ… z najprostszych jest **lista** - zezwala ona na przechowywanie elementÃ³w o rÃ³Å¼nych typach i swobodne odwoÅ‚anie siÄ™ do nich, a takÅ¼e Å‚atwe dodawanie i usuwanie wartoÅ›ci.
```{python, python.reticulate = FALSE}
s = [] # pusta lista
print(s)
print(type(s))
print("len:",len(s))
l = [1, 2, 3, 5, 7] # lista elementÃ³w typu int
print(l)
print(len(l))
a = [0] * 10 # lista o danym rozmiarze
print(a)
print(len(a))
```

Lista jest takÅ¼e *obiektem iterowalnym* - oznacza to, Å¼e jest przystosowana do "lecenia element po elemencie."
```{python, python.reticulate = FALSE}
b = list('lista')
print(b)
print(len(b))
mix = [7,'ğŸ‘»','rÃ³Å¼a', 3 + 2j] # w listach moÅ¼e byÄ‡ "wszystko"
print(mix)
print(len(mix))
print(type(mix[1]), mix[1]) # indeksujemy
```

Warto przyjrzeÄ‡ sie liÅ›cie takÅ¼e patrzÄ…c na rÃ³Å¼nicÄ™ *mutable* vs. *immutable*.
```{python, python.reticulate = FALSE}
m = [1, 2, 3]
n = m
print(id(m), m)
print(id(n), n)

m.append("sÅ‚oÅ„")
print(id(m), m)
print(id(n), n)
```

Przydaje siÄ™ funkcja *copy()*... bez zaskoczeÅ„ tworzÄ…ca kopiÄ™ danego obiektu.
```{python, python.reticulate = FALSE}
l = [1, 2, 3, 5, 7]
more_lists = l[:] #slices
more_list2 = l.copy()

print(id(l), l)
print(id(more_lists), more_lists)
print(id(more_list2), more_list2)
```

Bardzo przydatnÄ… umiejÄ™tnoÅ›ciÄ… jest zaznajomienie z obiektem **slice** (pl: wykrojenie?). SÅ‚uÅ¼y on do wygodnego tworzenia ciÄ…gÃ³w arytmetycznych, a takÅ¼e indeksowania po utworzonych sekwencjach.

SkÅ‚adnia *slice()* to **slice(start, stop, step)**.
```{python, python.reticulate = FALSE}
l = [1, 2, 3, 5, 7]
sl = slice(2, 5, 1)

print(type(sl), sl)
print(l[sl])
print(l[2:5:1]) 
print(l)
```

AbstrahujÄ…c od *wykrojeÅ„*, generalnie odwoÅ‚ywanie siÄ™ do rÃ³Å¼nych elementÃ³w listy w zaleÅ¼noÅ›ci od potrzeb niemalÅ¼e zawsze jest bardzo proste i Å‚atwe do napisania - przyjrzyjmy siÄ™ poniÅ¼szym przykÅ‚adom.
```{python, python.reticulate = FALSE}
lis = [1, 2, 3, 5, 7]
print(lis[-1])      # ostatni element
print(lis[-1:])     # ostatni element, ale ...
print(lis[::-1])    # odwrotna kolejnoÅ›Ä‡
print(lis[::2])     # elelemty z indeksami parzystymi
print(lis[:-2])     # caÅ‚a sekwencja poza ostatnimi dwoma elementami 
print(lis[1::2])    # elementy z indeksami nieparzystymi
```

Na pozornie podobnej zasadzie jak *slice* dziaÅ‚a **range**. Ten moÅ¼e przyjÄ…Ä‡ jeden, dwa lub trzy parametry:

* range(stop)
* range(start, stop)
* range(start, stop, step)

Przyjrzyj siÄ™ kolejnym wywoÅ‚aniom i pomyÅ›l: czym roÅ¼niÄ… siÄ™ *slice* i *range*?
```{python, python.reticulate = FALSE}
range_ = range(20)
print(type(range_),range_)

a = list(range(20))
b = [range(10, 20, 1)] 
c = list(range(10, 20, 1))
print("a:", a)
print("b:", b)
print("c:", c)
```

*SprawdÅº siÄ™!*

1. StwÃ³rz listÄ™ liczb od 0 do 500
2. Policz sumÄ™ wszystkich elementÃ³w tej listy
3. OdwrÃ³Ä‡ tÄ™ listÄ™
4. Dodaj na poczÄ…tek sÅ‚owo *PoweR*
5. StwÃ³rz listÄ™ parzystych liczb o dÅ‚ugoÅ›ci 50
6. Dla stringa "PoweR warsztaty i przygoda!", usuÅ„ wszystkie litery z 6 znaku aÅ¼ do koÅ„ca, wyÅ›wietl otrzymany string (oczekiwana wartoÅ›Ä‡: "PoweR ")
7. Mamy 2 stringi - s1 i s2. StwÃ³rz nowy string dodajÄ…c s2 w Å›rodku s1. PrzykÅ‚adowo:

* Przed: "Supplementary" i "Vector"

* Po: "SupplVectorementary"

8. Policz liczbÄ™ wystÄ…pieÅ„ litery *e* w stringu "PoweR is the best event evER" nie patrzÄ…c na wielkoÅ›Ä‡ litery (oczekiwana wartoÅ›Ä‡: 7)

... JednÄ… z naistotniejszych struktur danych w Pythonie sÄ… *tuple*, zwane takÅ¼e krotkami.
```{python, python.reticulate = FALSE}
a = () # pusta tuple
print(type(a), a)
a = (1,2,3,4) # deklaracja
print(type(a), a)
a = 1,2,3,4 # inna deklaracja 
print(type(a), a)
a = (1) # waÅ¼ne sÄ… przecinki, a nie nawiasy
print(type(a), a)
a = 1, # tuple z 1 elementem
print(type(a), a)
n_tuple = ("mouse", [8, 4, 6], (1, 2, 3))
print(type(n_tuple), n_tuple)
```

KolejnÄ… waÅ¼nÄ… strukturÄ… sÄ… **sÅ‚owniki** - ich idea to przechowywania *wartoÅ›ci* pod odpowiednimi *kluczami*. NaleÅ¼y pamiÄ™taÄ‡, Å¼e klucz jest tylko obiektem immutable (hashowalnym) i jeden klucz moÅ¼e mieÄ‡ tylko jednÄ… wartoÅ›Ä‡ (jeÅ¼eli bÄ™dzie dodane kilka par z tym samym kluczem, Python zapisze ostatni). Protip: jeÅ›li chcesz zapisaÄ‡ kolejnoÅ›Ä‡, w ktÃ³rej elementy zostaÅ‚y dodane do sÅ‚ownika, uÅ¼yj funkcji *collections.OrderedDict()*.
```{python, python.reticulate = FALSE}
a = dict() # pusty sÅ‚ownik
b = {} # alternatywa na deklaracje pustego sÅ‚ownika
c = {'klucz': 'wartoÅ›Ä‡'}
print(type(a), a)
print(type(b), b)
print(type(c), c)

a['new_key'] = 'new_value'  # Dodajemy nowy element do sÅ‚ownika
a[(7, 8)] = [('a', 'b', 'c'),'ğŸ¤–']
print(a)
a['new_key'] = 'ğŸ‘§'
print(a)
```

JeÅ›li klucz nie wystÄ™puje w sÅ‚owniku, pojawia siÄ™ error. Å»eby tak nie byÅ‚o trzeba dodatkowo zdefiniowaÄ‡ zachowanie *\_\_missing\_\_(key)*. PoniÅ¼sze operacje nie zadziaÅ‚ajÄ… poprawnie.
```{python, python.reticulate = FALSE, eval = FALSE}
print(c['nieklucz'])
a[[1, 2]] = 'nie dziaÅ‚a'
```

Do przechowywania wartoÅ›ci unikalnych, przyda nam sie **set** - zbiÃ³r. NajproÅ›ciej mÃ³wiÄ…c jest to â€kontenerâ€ zawierajÄ…cy niepowtarzalne elementy w losowej kolejnoÅ›ci. Czas sprawdzenia czy jakiÅ› obiekt jest w zbiorze jest staÅ‚y, w porÃ³wnaniu do listy albo krotki, w ktÃ³rych czas jest liniowo zaleÅ¼ny od liczby elementÃ³w.
```{python, python.reticulate = FALSE, eval = FALSE}
a = set()
print(type(a), a)

a = {} # nie set , a ...
print(type(a), a)

a = {'a', 'b', 'c', 'd'}
print(type(a), a)

mixed_set = {2.0, "Nicholas", (1, 2, 3)} 
print(type(mixed_set), mixed_set)

mixed_set.add("Katty") 
print(type(mixed_set), mixed_set)
```

JeÅ¼eli chcielibyÅ›my dodaÄ‡ do zbioru element juÅ¼ w nim bÄ™dÄ…cy - set go zignoruje.
```{python, python.reticulate = FALSE, eval = FALSE}
a = {[1,2,3], [1,2,3]}
```

### Operatory

W celu wykonania operacji arytmetycznych i dokonania innych ingerencji miÄ™dzy obiektami, skÅ‚adnia jest prosta i nieodbiegajÄ…ca od standardu innych jÄ™zykÃ³w programowania.

**Arytmetyczne:**

* + dodawanie
* - odejmowanie
* * mnoÅ¼enie
* ** potÄ™gowanie
* / dzielenie -> float
* // dzielenie z zaokrÄ…gleniem do najbliÅ¼szego int w dÃ³Å‚
* % reszta z dzielenia

**PorÃ³wnania:**

* == rÃ³wne co do wartoÅ›ci
* != rÃ³Å¼ne co do wartoÅ›ci
* *is* zwraca true, jeÅ›li obie zmienne sÄ… tym samym obiektem (porÃ³wnuje wyniki funkcji id, adresy obiektÃ³w przechowywane w pamiÄ™ci)
* *is not* zwraca true, jeÅ›li obie zmienne nie sÄ… tym samym obiektem
* < mniejsze
* > wiÄ™ksze
* >= wiÄ™ksze lub rÃ³wne
* \<= mniejsze lub rÃ³wne
* *in* zwraca wartoÅ›Ä‡ True, jeÅ›li w obiekcie znajduje siÄ™ sekwencja o okreÅ›lonej wartoÅ›ci (np litera w stringu)
* *not in* czy obiekt nie jest zawarty w innym obiekcie

**Logiczne:**

* *and* zwraca wartoÅ›Ä‡ True, jeÅ›li obie instrukcje sÄ… prawdziwe x < 5 and x < 10
* *or* zwraca wartoÅ›Ä‡ True, jeÅ›li jedno z wyraÅ¼eÅ„ jest prawdziwe x < 5 or x < 4
* *not* odwraca wynik, zwraca False, jeÅ›li wynik jest prawdziwy(x < 5 and x < 10)

TrochÄ™ o operatorze **in**:
1. W listach sÄ… przeszukiwane wszystkie elementy po kolei. Czas wyszukiwania zaleÅ¼y od rozmiaru listy.
2. Dla zbiorÃ³w wyszukiwanie nie zaleÅ¼y od rozmiaru zbioru - jest staÅ‚e
3. W przypadku sÅ‚ownikÃ³w wyszukiwane sÄ… tylko klucze, czas wyszukiwania nie zaleÅ¼y od liczby elementÃ³w w sÅ‚owniku. Åšrednio *O(1)*

**Uwaga!** Do porÃ³wnywania stosujemy tylko *==*. Jest to bardzo waÅ¼ne, gdyÅ¼ niedbaÅ‚e mylenie *==* z *=* to typowy bÅ‚Ä…d poczÄ…tkujÄ…cych programistÃ³w, ktÃ³ry niezwykle czÄ™sto doprowadza do porozumieÅ„ i zepsucia kodu tylko przez tÄ… jednÄ… literkÄ™, ktÃ³rÄ… niekiedy i wychwyciÄ‡ nieÅ‚atwo.

Zobaczmy nasze oparatory w akcji.
```{python, python.reticulate = FALSE}
x = 256
y = 256
print('id(x)', id(x))
print('id(y)', id(y))
print('x is y', x is x)
print('x == y', x == y)

x = 257
y = 257
print('id(x)', id(x))
print('id(y)', id(y))
print('x is y', x is y)
print('x == y', x == y)
```

ZwrÃ³Ä‡ uwagÄ™, jak zmieniÅ‚o siÄ™ zachowanie Pythona dla operatorÃ³w *==* i *is* - dzieje siÄ™ tak dlatego, Å¼e zwzglÄ™dÃ³w optymalizacyjnych liczby "maÅ‚e" sÄ… nieco inaczej interpretowane.

### Instrukcja warunkowa

... to element jÄ™zyka pozwalajÄ…cy na wybÃ³r rÃ³Å¼nych Å›cieÅ¼ek operacji w zaleÅ¼noÅ›ci od speÅ‚nionych warunkÃ³w. Kluczowa jest umiejÄ™tnoÅ›Ä‡ uÅ¼ytku i rozumienia instrukcji **if**, **else** i **elif** (skrÃ³t od *else if*). DziaÅ‚ajÄ… one niemalÅ¼e tak, jak moÅ¼na by siÄ™ spodziewaÄ‡ po ich tÅ‚umaczeniach.

```{python, python.reticulate = FALSE}
x = 10
print('przed ifem')
if x == 10:
    print('x=10')
elif x == 4:
    print('x=4')
elif x == 5:
    print('x=5')
else:
    print('else')
print('po ifie')
```

### PÄ™tle

W celu wykonania danego bloku operacji wiele razy korzystamy z pÄ™tli. Tak jak i w przypadku innych popularnych jÄ™zykÃ³w programowania, kluczowa jest znajomoÅ›Ä‡ **for** i **while**.

Na tÄ… pierwszÄ… najwygodniej patrzeÄ‡ jak na pÄ™tlÄ™ "*dla kaÅ¼dego...*". Oto jej dziaÅ‚anie:
```{python, python.reticulate = FALSE}
for number in range(5): 
    print(number)
```

IterowaÄ‡ moÅ¼emy po po dowolnych iterowalnych obiektach.
```{python, python.reticulate = FALSE}
mix = [7,'ğŸ‘»','rÃ³Å¼a', 3 + 2j] 
for el in mix: 
    print(el)
    
print("==========================================================================")    

for i in 'hello world':
    print(i * 2, end = '')
```

W celu przerwania dziaÅ‚ania pÄ™tli korzystamy z instrukcji **break**, zaÅ› kiedy chcemy rozpoczÄ…Ä‡ nastÄ™pny obrÃ³t pÄ™tli, omijajÄ…c pozostaÅ‚Ä… czÄ™Å›Ä‡ - uÅ¼ywamy **continue**.
```{python, python.reticulate = FALSE}
for i in 'hello world':
    if i == 'e':
        break
    print(i * 2, end = '')
```

```{python, python.reticulate = FALSE}
for i in 'hello world':
    if i == 'o':
        continue
    print(i * 2, end = '')
```

Przydatna jest teÅ¼ operacja **else** dla pÄ™tli - wykona siÄ™ ona, jeÅ›li pÄ™tla zakoÅ„czyÅ‚a siÄ™ normalnie (nie za pomocÄ… *break*).
```{python, python.reticulate = FALSE}
for i in 'hello world':
    if i == 'a':
        break
else:
    print('Nie ma takiej litery')
```

DrugÄ… pÄ™tlÄ… jakiej moÅ¼emy uÅ¼yÄ‡ w Pythonie jest **while** - zezwala ona na wykonywanie operacji w bloku kodu jej przeznaczonym tak dÅ‚ugo, aÅ¼ wpisany przez programistÄ™ warunek bÄ™dzie speÅ‚niony.

Intuicja: *while* to taki *if* wykonywany wielokrotnie [o ile warunek jest speÅ‚niany].
```{python, python.reticulate = FALSE}
i = 5
while i < 15:
    print(i)
    i = i + 2
```

Rezultaty pÄ™tli *for* moÅ¼emy takÅ¼e zapisywaÄ‡ w taki oto skrÃ³towy sposÃ³b:
```{python, python.reticulate = FALSE}
squares = []
for x in range(10):
    squares.append(x ** 2)
print(squares)


squares = [x**2 for x in range(10)]
print (squares)

b = [x for x in range(10) if not x%3] # lista liczb podzielnych przez 3 and < 10 
print(b)
```

MoÅ¼na takÅ¼e skÅ‚adaÄ‡ zbiory i sÅ‚owniki.
```{python, python.reticulate = FALSE}
a = {str(i):i for i in [1,2,3,4,5]} # sÅ‚ownik
print(a)
a = {x for x in  range(10) } # set
print(a)
```

Oraz tuple. Tylko uwaÅ¼aj!
```{python, python.reticulate = FALSE}
a = (x for x in range(10)) # generatory
print(type(a))
print(next(a))
print(next(a))
b = tuple(x for x in range(10)) # tuple
print(type(b))
```

*SprawdÅº siÄ™!*

1. Mamy 2 listy. Wypisz *True* jeÅ›li pierwszy i ostatni element na liÅ›cie jest taki sam
2. ZrÃ³b listÄ™ od 1 do 100 i wypisz wszystkie liczby podzielne przez 5
3. Wypisz takÄ… piramidÄ™

1

2 2

3 3 3

4 4 4 4

5 5 5 5 5

*(PamiÄ™taj o print (..., end=" "))*

4. PoÅ‚Ä…cz dwie listy tak, Å¼e do wynikowej listy z pierwszej bÄ™dÄ… liczby nie parzyste, a z drugiej parzyste. PrzykÅ‚adowo:

*list1 = [15, 22, 23, 17, 19]*
*list2 = [24, 43, 24, 36, 11]*
*Merged List is [15, 23, 17, 19, 24, 24, 36]*

5. Policz wystÄ…pienia kolejnych elementÃ³w i na podstawie tego stwÃ³rz sÅ‚ownik. PrzykÅ‚adowo:

*list1 = [121, 43, 87, 121, 23, 43, 43, 43, 87]*
*dict1 = {121: 2, 43: 4, 87: 2, 23: 1}*

6. Rozpakuj krotkÄ™ do wartoÅ›ci
7. ZamieÅ„ wszystkie ostatnie wartoÅ›ci w tuple na 99. PrzykÅ‚adowo:

*l1 = [(10, 20, 40), (40, 50, 60), (70, 80, 90)]*
*result = [(10, 20, 99), (40, 50, 99), (70, 80, 99)]*

8. Mamy listÄ™ *mix[string, int , float ...]*. StwÃ³rz nowÄ… listÄ™ ktÃ³ra bÄ™dzie miaÅ‚a tylko *int*.

### Funkcje

W Pythonie definiuje siÄ™ je za pomocÄ… sÅ‚owa kluczowego **def**:
```{python, python.reticulate = FALSE}
def func():
    print("Hi, dear!")

func()
```

W zaleÅ¼noÅ›ci od deklaracji, funkcja moÅ¼e przyjÄ…Ä‡ dowolnÄ… liczbÄ™ argumentÃ³w o niemalÅ¼e ograniczonej swobodzie wyboru typÃ³w.
```{python, python.reticulate = FALSE}
def greet(name):
    """This function greets to the person passed in as parameter"""
    print("Hello, " + name + ". Good morning!")
    
print(greet.__doc__)
greet("Kate")
```

W przypadku podawania argumentÃ³w **pozycyjnie**, podaje siÄ™ je po nazwie funkcji w nawiasach. MoÅ¼esz dodaÄ‡ dowolnÄ… liczbÄ™ argumentÃ³w - po prostu oddziel je przecinkiem.
```{python, python.reticulate = FALSE}
def func(name):
    return name + " Ref"

a = func("Katty")
print(a)
print(func("Lila"))
print(func("Ewa"))
```

MoÅ¼na teÅ¼ podawaÄ‡ argumenty **kluczowo**, tj. przez nazwanie. Wtedy kolejnoÅ›Ä‡ jest niewaÅ¼na.
```{python, python.reticulate = FALSE}
def func(person3, person2, person1):
    print("Imie ryczerza to " + person3)

func(person1 = "Emil", person2 = "Tobias", person3 = "Linus")
```

```{python, python.reticulate = FALSE}
def func(x = 1, y = 1):
    outcome = x + y
    print(outcome)

func(x = 100)
```

Uwaga z kolejnoÅ›ciÄ… argumentÃ³w z wartoÅ›ciami *default*! Deklaracja poniÅ¼szej funkcji nie bÄ™dzie poprawna.
```{python, python.reticulate = FALSE, eval = FALSE}
def greet(msg = "Good morning!", name):
    pass
```

MoÅ¼na za to napisaÄ‡ w taki sposÃ³b:
```{python, python.reticulate = FALSE}
def gree(name, msg = "Good morming!"):
    pass
```

Python daje takÅ¼e moÅ¼liwoÅ›Ä‡ uÅ¼ycia *Args - arbitrary arguments*. JeÅ›li nie wiesz, ile argumentÃ³w zostanie przekazanych do funkcji, dodaj gwiazdkÄ™ przed nazwÄ… parametru w definicji funkcji.
```{python, python.reticulate = FALSE}
def func(*args):
    print(type(args))
    print("Imie ryczerza to " + args[2])

func("Emil", "Tobias", "Linus")
```

SÄ… takÅ¼e i *Kwargs - arbitrary keyword arguments*. JeÅ›li nie wiesz, ile argumentÃ³w nazwanych zostanie przekazanych do funkcji, dodaj dwie gwiazdki przed nazwÄ… parametru w definicji funkcji.
```{python, python.reticulate = FALSE, eval = FALSE}
def func_kwargs(**places):
    print("Jestem z " + places["region"] + " wojewÃ³dztwa")

func_kwargs(city = "Warszawa", region = "ÅÃ³dzkiego")
```

PamiÄ™tajmy o *Mutable vs. Immutable*! PoniÅ¼ej niepoprawnie zadeklarowana funkcja i tego efekty:
```{python, python.reticulate = FALSE}
def printing(lista = []):
    lista.append('print')
    for el in lista:
        print(id(lista), el)
        
printing()

li = ['nowe sÅ‚owo']
print(id(li))
printing(li)

printing()
```

NiÅ¼ej juÅ¼ poprawna implementacja i jej wywoÅ‚anie:
```{python, python.reticulate = FALSE}
def printing(lista = None):
    print("Przed if: ",id(lista))
    lista = lista if lista else [] # druga opcja lista or []
    print("Po if: ", id(lista))
    lista.append('print')
    for el in lista:
        print(id(lista), el)

printing()

printing()

l = ['nowe sÅ‚owo']
print("Przed wywoÅ‚aniem funkcji: ", id(l))
printing(l)
```

*SprawdÅº siÄ™!*

1. Napisz program, ktÃ³ry znajdzie wszystkie takie liczby, ktÃ³re sÄ… podzielne przez 7, ale nie sÄ… wielokrotnoÅ›ciÄ… 5, od 2000 do 3200 (wÅ‚Ä…cznie). Otrzymane liczby naleÅ¼y wydrukowaÄ‡ w oddzielonej przecinkami sekwencji w jednym wierszu.

2. 
Napisz funkcjÄ™, ktÃ³ra oblicza i drukuje wartoÅ›Ä‡ zgodnie z podanÄ… formuÅ‚Ä…: *Q = (2 \* C \* D) / H*, gdzie:

* C - argument nienazwany - integer
* D - argument nienazwany - integer
* H - nie wiadomo ile jest argumentÃ³w nienazwanych (jeÅ¼eli wiÄ™cej niÅ¼ 1 to zsumowaÄ‡ H1 + H2 + H3)

3. ZrÃ³b funkcjÄ™, przyjmujÄ…cÄ… listÄ™ *tuple*, indeks("i") i wartoÅ›Ä‡("w"). ZamieÅ„ wszystkie wartoÅ›ci na indeksie "i" w tuple na wartoÅ›Ä‡ ("w"). PrzykÅ‚adowo:

*l1 = [(10, 20, 40), (40, 50, 60), (70, 80, 90)]*

*change(l1,1,77)*

*result = [(10, 77, 40), (40, 77, 60), (70, 77, 90)]*

### Ramka danych i *pandas* - maÅ‚y wstÄ™p

W kolejnych krokach bÄ™dziemy braÄ‡ pod lupÄ™ dwa rodzaje tabel:

1. **Series** - jest to jednowymiarowa struktura danych (â€jednowymiarowa tablicaâ€), ktÃ³ra moÅ¼e przechowywaÄ‡ wartoÅ›ci i dla kaÅ¼dej wartoÅ›ci ma takÅ¼e unikalny indeks
2. **DataFrame** - dwuwymiarowa (lub wiÄ™cej) wymiarowa struktura danych - w zasadzie tabela z wierszami i kolumnami. Kolumny majÄ… nazwy, a wiersze indeksy.

**Pandas** to doskonaÅ‚a biblioteka implementujÄ…ca wiele przydatnych narzedzi do obrÃ³bki i pracÄ… nad ramkÄ… danych. Aby mÃ³c korzystaÄ‡ z jej mocy, musimy wczytaÄ‡ (i ewentualnie zainstalowaÄ‡, jeÅ¼eli nie zostaÅ‚o to wczeÅ›niej zrobione) pakiet. Standardowo przyjÄ™Å‚o siÄ™ wczytywaÄ‡ go jako *pd* - dodanie do instrukcji wczytywania biblioteki magicznych czterech liter *as pd* zezwoli nam na moÅ¼liwoÅ›Ä‡ odwoÅ‚ywania sie w kaÅ¼dym kolejnym kroku kiedy bÄ™dziemy potrzebowaÄ‡ *pandas* nie do caÅ‚ej szeÅ›cioliterowej nazwy pakietu, ale tylko do tych dwÃ³ch prostych znakÃ³w.

JeÅ¼eli nie masz jeszcze zainstalowanego pakietu *pandas* - uÅ¼yj instrukcji jak niÅ¼ej.

```{python, python.reticulate = FALSE, eval = FALSE}
install.packages("pandas")
```

```{python, python.reticulate = FALSE, eval = FALSE}
import pandas as pd
```

DziÄ™ki *pandas* moÅ¼emy Å‚atwo wczytywaÄ‡ gotowe pliki *.csv*. Instrukcja **read_csv** standardowo przyjmuje dwa argumenty - Å›cieÅ¼kÄ™ do pliku i opcjonalnie *delimiter* - sposÃ³b, w jaki oddzielone sÄ… kolejne wartoÅ›ci w wierszach.
```{python, python.reticulate = FALSE, eval = FALSE}
data = pd.read_csv("files/movies.csv", delimiter = ',')
```

Tak utworzona ramka danych ma swÃ³j wÅ‚asny typ.
```{python, python.reticulate = FALSE, eval = FALSE}
print(type(data.head()))
```

MoÅ¼emy Å‚atwo odwoÅ‚aÄ‡ siÄ™ do pierwszych lub ostatnich wierszy data frame za pomocÄ… metod **head()** i **tail()**.
```{python, python.reticulate = FALSE, eval = FALSE}
display(data.tail())
display(data.head())
```

Do zwrÃ³cenia losowych rows uÅ¼ywamy **sample()**.
```{python, python.reticulate = FALSE, eval = FALSE}
data.sample(5)
```

MoÅ¼emy takÅ¼e Å‚atwo odwoÅ‚aÄ‡ siÄ™ do wierszy speÅ‚niajÄ…cych podane kryteria. PrzykÅ‚adowo poniÅ¼sza instrukcja zwrÃ³ci nam te, dla ktÃ³rych wartoÅ›Ä‡ odpowiadajÄ…ca za *title* przyjmuje "Apaches*.
```{python, python.reticulate = FALSE, eval = FALSE}
data[data.title == "Apaches"]
```

*SprawdÅº siÄ™!*

1. SprawdÅº szczegÃ³Å‚owe informacje o *DataFrame*
2. Uzyskaj pierwsze 3 wiersze danych
3. WyÅ›wietl kolumny *title* i *description*
4. WyÅ›wietl kolumny *show_id*, *country*, *data_added* dla wierszy 0, 3, 6, 24
5. WyÅ›wietl wiersze gdzie *release_year* > 2010
6. WyÅ›wietl wiersze, gdzie *director* is *NaN*
7. Policz ile jest takich wierszy jak w punkcie 5.
8. SprawdÅº typ kolumny *duration*
9. SprawdÅº co to znaczy
10. ZmieÅ„ nazwÄ™ kolumny *title* na *name*
Dodaj nowy wiersz